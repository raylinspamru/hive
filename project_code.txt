ПОЛНЫЙ КОД ПРОЕКТА
==================================================

==================================================
Файл: config.py
==================================================

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    BOT_TOKEN: str
    ADMIN_IDS: list[int] = []
    DATABASE_URL: str = "sqlite+aiosqlite:///bot.db"
    DIRECTOR_LOGIN: str = "director"
    DIRECTOR_PASSWORD: str = "artepass758"

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()

==================================================
Файл: exweb.py
==================================================

import os
from datetime import datetime

def collect_project_code(output_file="project_code.txt"):
    # Список папок для поиска файлов
    directories = [
        "static/js",    # для .js файлов
        "web",          # для .py файлов
        "utils",        # для .py файлов
        "templates"     # для .html файлов
    ]
    
    # Папки для игнорирования
    ignore_dirs = {"venv", "__pycache__"}
    
    # Расширения файлов и их соответствующие папки
    file_extensions = {
        ".py": ["web", "utils", ""],  # "" для main.py в корне
        ".html": ["templates"],
        ".js": ["static/js"],
        ".txt": ["static/js", "web", "utils", "templates"]
    }
    
    # Открываем файл для записи
    with open(output_file, "w", encoding="utf-8") as outfile:
        # Записываем заголовок с датой
        current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        outfile.write(f"Project Code Collection - Generated on {current_date}\n")
        outfile.write("=" * 50 + "\n\n")
        
        # Сначала обработаем main.py в корневой директории
        if os.path.exists("main.py"):
            outfile.write("File: main.py\n")
            outfile.write("-" * 50 + "\n")
            with open("main.py", "r", encoding="utf-8") as f:
                outfile.write(f.read())
            outfile.write("\n" + "=" * 50 + "\n\n")
        
        # Обработка всех указанных директорий
        for directory in directories:
            if not os.path.exists(directory):
                continue
                
            for root, dirs, files in os.walk(directory):
                # Исключаем игнорируемые директории
                dirs[:] = [d for d in dirs if d not in ignore_dirs]
                
                for file in sorted(files):  # Сортируем файлы для порядка
                    # Проверяем расширение файла
                    file_ext = os.path.splitext(file)[1].lower()
                    if file_ext in file_extensions:
                        # Проверяем, соответствует ли директория расширению
                        if directory in file_extensions[file_ext] or "" in file_extensions[file_ext]:
                            file_path = os.path.join(root, file)
                            relative_path = os.path.relpath(file_path)
                            
                            # Пропускаем файлы из игнорируемых директорий
                            if any(ignore_dir in relative_path.split(os.sep) for ignore_dir in ignore_dirs):
                                continue
                            
                            # Записываем информацию о файле
                            outfile.write(f"File: {relative_path}\n")
                            outfile.write("-" * 50 + "\n")
                            
                            # Читаем и записываем содержимое файла
                            try:
                                with open(file_path, "r", encoding="utf-8") as f:
                                    content = f.read()
                                    outfile.write(content)
                            except Exception as e:
                                outfile.write(f"Error reading file: {str(e)}\n")
                            
                            outfile.write("\n" + "=" * 50 + "\n\n")

def main():
    try:
        collect_project_code()
        print("Код проекта успешно собран в файл project_code.txt")
    except Exception as e:
        print(f"Произошла ошибка: {str(e)}")

if __name__ == "__main__":
    main()

==================================================
Файл: main.py
==================================================

# main.py
import logging
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from config import settings
from bot.handlers import router as handlers_router
from bot.adminpanel import adminpanel_router
from bot.basic_handlers import router as basic_router
from utils.database import engine as async_engine, init_db
from utils.notifications import init_notifications
from web import app as quart_app, set_notification_service

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=settings.BOT_TOKEN)
dp = Dispatcher(storage=MemoryStorage())

async def main():
    logging.info("Инициализация базы данных...")
    await init_db()

    dp.include_router(basic_router)
    dp.include_router(adminpanel_router)
    dp.include_router(handlers_router)

    notifications = init_notifications(bot)
    set_notification_service(notifications)

    notifications.start()  # Синхронный вызов, так как start() больше не корутина

    web_task = asyncio.create_task(quart_app.run_task(host='localhost', port=5000, debug=True))
    polling_task = asyncio.create_task(dp.start_polling(bot, skip_updates=True))

    logging.info("Бот и веб-интерфейс запущены!")
    try:
        await asyncio.gather(web_task, polling_task)
    except KeyboardInterrupt:
        logging.info("Завершаем работу...")
        await notifications.shutdown()
        web_task.cancel()
        polling_task.cancel()
        await bot.session.close()
        await async_engine.dispose()
        await asyncio.sleep(1)
    finally:
        logging.info("Бот и веб-интерфейс остановлены.")

if __name__ == "__main__":
    asyncio.run(main())

==================================================
Файл: requirements.txt
==================================================

aiofiles==24.1.0
aiogram==3.17.0
aiohappyeyeballs==2.6.1
aiohttp==3.11.14
aiosignal==1.3.2
aiosqlite==0.21.0
annotated-types==0.7.0
APScheduler==3.11.0
asyncpg==0.30.0
attrs==25.1.0
blinker==1.9.0
certifi==2025.1.31
click==8.1.8
colorama==0.4.6
et_xmlfile==2.0.0
Flask==3.0.3
Flask-SQLAlchemy==3.1.1
frozenlist==1.5.0
greenlet==3.1.1
h11==0.14.0
h2==4.2.0
hpack==4.1.0
Hypercorn==0.17.3
hyperframe==6.1.0
idna==3.10
itsdangerous==2.2.0
Jinja2==3.1.6
magic-filter==1.0.12
MarkupSafe==3.0.2
multidict==6.1.0
numpy==2.2.3
openpyxl==3.1.5
pandas==2.2.3
pillow==11.1.0
priority==2.0.0
propcache==0.2.1
pydantic==2.10.6
pydantic-settings==2.7.1
pydantic_core==2.27.2
python-dateutil==2.9.0.post0
python-dotenv==1.0.1
pytz==2025.1
Quart==0.20.0
quart-auth==0.11.0
six==1.17.0
SQLAlchemy==2.0.38
typing_extensions==4.12.2
tzdata==2025.1
tzlocal==5.3.1
Werkzeug==3.1.3
wsproto==1.2.0
XlsxWriter==3.2.2
yarl==1.18.3

==================================================
Файл: запрос.txt
==================================================


Наш план реализации:

Шаг 1: Настройка базового Quart-приложения и авторизации
Обновим web/__init__.py для поддержки сессий и авторизации.
Создадим templates/login.html для страницы входа.
Настроим маршруты для входа и выхода.
Шаг 2: Реализация главной страницы (dashboard)
Создадим web/dashboard.py и templates/dashboard.html.
Добавим кнопки для перехода на страницы задач, ролей, меню и рассылки.
Шаг 3: Реализация страницы задач
Создадим web/tasks.py и templates/tasks.html.
Реализуем таблицу задач, фильтры, пагинацию, модальные окна (добавление, редактирование, статистика, уведомления).
Интегрируем уведомления с utils/notifications.py.
Шаг 4: Реализация страницы ролей и пользователей
Создадим web/roles.py и templates/roles.html.
Реализуем таблицу ролей, редактирование, привязку пользователей, генерацию паролей.
Шаг 5: Реализация динамического меню
Создадим web/dynmenu.py и templates/dynmenu.html.
Реализуем таблицу кнопок с возможностью редактирования и экспорта.
Шаг 6: Реализация страницы рассылки
Создадим web/messages.py и templates/messages.html.
Реализуем базовую функциональность рассылки (пока как заглушку).
Шаг 7: Интеграция и финальная настройка
Добавим utils/notifications.py для управления уведомлениями через APScheduler.
Настроим взаимодействие между ботом и веб-интерфейсом (например, отправку паролей через bot).


Сейчас мы на шаге 3 и возможно мы сразу делаем вместе с ним шаг 7.

Вот описание веб-интерфейса:

Общее описание веб-интерфейса


Веб-интерфейс представляет собой административную панель, разработанную с использованием фреймворка Quart (асинхронная альтернатива Flask) и стилизованную с помощью Bootstrap 5.3. Он предназначен для директора, который управляет задачами, ролями и пользователями своего Telegram-бота, написанного на aiogram. Интерфейс включает авторизацию, главную страницу с четырьмя основными разделами ("Задачи", "Роли и пользователи", "Динамическое меню", "Рассылка") и функционал для управления задачами, ролями, уведомлениями сотрудников через Telegram, а также настройкой меню бота.

В проекте веб-интерфейс должен быть выполнен строго модульно: каждая функция реализована на отдельной независимой странице, а не объединена в одном файле dashboard.html. Страницы "Задачи", "Роли и пользователи", "Динамическое меню" и "Рассылка" являются автономными и связаны между собой только через главную страницу. Такой подход обеспечивает гибкость: в любой момент можно добавить новую страницу с дополнительными функциями или удалить существующую без влияния на остальные компоненты системы. Для каждой страницы предусмотрен свой отдельный файл HTML в папке templates и соответствующий файл Python в папке web, что упрощает поддержку и масштабирование проекта.
Структура проекта должна выглядеть следующим образом:
web/
    __init__.py
    tasks.py
    roles.py
    dynmenu.py
    messages.py
templates/
    login.html
    dashboard.html
    tasks.html
    tasks_stats.html
    roles.html
    dynmenu.html
    messages.html
Дополнительные файлы могут быть добавлены при необходимости.


1. Страница входа (login.html)
Описание
Это первая страница, которую видит пользователь при входе в веб-интерфейс. Она предназначена для авторизации директора.
Элементы интерфейса
Заголовок: "Вход для руководителя".
Форма авторизации:
посередине страницы
Поле "Логин": Текстовое поле для ввода логина (обязательное).
Поле "Пароль": Поле для ввода пароля (обязательное, скрывает символы).
Кнопка "Войти": Отправляет форму на сервер для проверки данных.
Сообщение об ошибке: Если логин или пароль неверные, появляется красное уведомление с текстом "Неверный логин или пароль".
Как работает
Пользователь вводит логин и пароль, которые сравниваются с значениями DIRECTOR_LOGIN и DIRECTOR_PASSWORD из файла настроек (settings).
При успешной авторизации пользователь перенаправляется на главную страницу.
При ошибке отображается сообщение, и пользователь остается на странице входа.

2. Главная страница (dashboard.html или другой файл)
Описание
После успешной авторизации директор попадает на главную страницу, которая представляет собой панель управления в ней есть 4 кнопки: "Задачи", "Роли и пользователи", "Динамическое меню" и “Рассылка”. Это основное рабочее пространство для управления задачами и сотрудниками, меню и прочим.
Общие элементы интерфейса
Заголовок: "Главная".
Кнопки управления (в правом верхнем углу):
"Обновить" (иконка часов с круговой стрелкой): Перезагружает страницу для обновления данных.
"Выйти" (иконка выхода): Завершает сессию и возвращает на страницу входа (/login).
Статистика( Продумать, что тут может быть): - пока пустует.

Инструкция(продумать): Инструкция.

Кнопки:
"Задачи”.
"Роли и пользователи".
"Динамическое меню".
“Рассылка”.

"Задачи"


Описание


Эта вкладка позволяет директору просматривать, добавлять, редактировать и удалять задачи для сотрудников, а также фильтровать их по различным критериям.
Элементы интерфейса


Фильтры и поиск:
Состояние:
Выпадающий список: "Все состояния", "Принято", "Отправлено", "Выполнено", "Просрочено".
При выборе фильтр применяется автоматически.
Дедлайн:
Выпадающий список: "Все дедлайны", "Просрочены", "Сегодня", "В будущем".
При выборе фильтр применяется автоматически.
Исполнитель:
Выпадающий список: "Все исполнители" + список групп ролей из базы данных (role_group_name (например, "Вожатый", "Диджей", если выбирается группа у которой есть подгруппы, например вожатый, то дается выбор: все {role_group_name} (Вожатый) и список из {role_full_name} (Вожатый 1-го отряда, Вожатый 2-го отряда и т.д.)).
При выборе фильтр применяется автоматически.
Частота:
Выпадающий список: "Все частоты" + список существующих частот повторения задач из базы данных (например, "Раз в 30 минут", "Раз в 1 час", "Раз в 2 дня", "Раз в 1 неделю", "Раз в 3 месяца", "Раз в 1 год").
Частоты отображаются только для задач, у которых уже настроено повторение.
При выборе фильтр применяется автоматически.
Поиск по описанию:
Текстовое поле для ввода текста.
Работает после нажатия кнопки "Применить".
Кнопка "Применить" (иконка воронки): Применяет фильтр поиска.
Кнопка "Сбросить" (иконка крестика): Сбрасывает все фильтры и возвращает к полному списку задач.
Кнопка "Добавить задачу" (иконка плюса):
Открывает модальное окно для создания новой задачи (см. ниже "Модальное окно добавления задачи").
Уведомления:
Зеленые сообщения (например, "Задача успешно добавлена!") появляются после успешных действий и исчезают при закрытии.
Таблица задач:
Колонки:
№: Номер задачи (task_id).
Исполнитель: Название роли (role_name, если задача дана всей роли (например Всем Вожатый или Диджей (так как у диджея нет подгрупп))) или "Все сотрудники", если role_id = "all" или {role_full_name} (например Вожатый 1-го отряда, если задача дана role_group=voz, role_subgroup=1 и также для других).
Описание: Краткое описание задачи (обрезается с многоточием, если длинное; полный текст виден при наведении).
Состояние:
Если задача дана не всем и не группе: "Отправлено", "Принято", "Выполнено" или "Просрочено".
Если дана группе или всем, то написано "см. статистика".
Срок: Дата и время в формате "ЧЧ:ММ ДД.ММ.ГГГГ" или "-" если не указан.
Действия: Кнопки управления задачей.
Кнопки в столбце "Действия":
"Статистика" (иконка гистограммы): Показывает статистику выполнения задачи (доступно только для задач с role_id = "all" или групповых ролей). Открывает модальное окно "Статистика задачи".
"Редактировать" (иконка карандаша): Открывает модальное окно для редактирования задачи.
"Удалить" (иконка корзины): Удаляет задачу после подтверждения ("Вы уверены...?").
"Уведомления" (иконка колокольчика): Открывает модальное окно для настройки уведомлений задачи (см. ниже "Модальное окно настройки уведомлений").
Модальное окно "Добавление задачи"
Заголовок: "Добавить задачу".
Поля:
Исполнитель: Выпадающий список ролей ("Все сотрудники" + роли из базы (role_group_name)). При выборе групповой роли появляется поле "Подгруппа".
Подгруппа: Выпадающий список подгрупп отображается role_full_name, например "Вожатый 1-го отряда" для role_group=voz, role_subgroup=1). По умолчанию "Всем в этой роли".
Описание: Текстовое поле (многострочное, обязательное).
Дедлайн: Поле выбора даты и времени (datetime-local). Дополнительно кнопки:
"Сегодня": Устанавливает текущую дату и время.
"Завтра": Устанавливает дату на следующий день.
"Через неделю": Устанавливает дату через 7 дней.
Повторение: Выпадающий список: "Нет", "Ежедневно", "Еженедельно", "Каждые n минут (при нажатии на это появляется дополнительное окошко: Введите количество минут)", "Каждые n часов (при нажатии на это появляется дополнительное окошко: Введите количество часов)", "Каждые n дней (при нажатии на это появляется дополнительное окошко: Введите количество дней)".
Отправка уведомления: Выпадающий список:
"Отправить сейчас" (по умолчанию): Уведомление отправляется сотрудникам сразу после создания задачи.
"В момент дедлайна": Уведомление отправляется только в момент наступления дедлайна (если дедлайн указан).
"Не отправлять": Уведомление не отправляется автоматически (можно настроить вручную позже).
"Настроить уведомления": Открывает дополнительный блок настройки уведомлений (см. ниже "Дополнительная настройка уведомлений").
Дополнительная настройка уведомлений (появляется при выборе "Настроить уведомления"):
Тип уведомления: Выпадающий список:
"Однократное": Уведомление отправляется один раз в указанное время.
"Повторяющееся": Уведомление отправляется с заданной частотой в заданный период.
Для "Однократное":
Время отправки: Поле выбора конкретного времени ЧЧ:ММ ДД:ММ:ГГГГ или выбор "За сколько до дедлайна" (например, "За 5 часов", "За 2 дня") с выпадающим списком единиц (минуты, часы, дни, недели,месяцы).
Для "Повторяющееся":
Частота: Выпадающий список: "Каждые n минут", "Каждые n часов", "Каждые n дней" (с полем ввода числа N).
Период: Поля Выбор конкретного времени начала и окончания ДД:ММ:ГГГГ или выбор "Начать за" (например, "За 5 часов до дедлайна") и "Закончить" (например, "В момент дедлайна" или "За 2 часа после дедлайна") с единицами (минуты, часы, дни).
Время отправки: Чекбокс "Фиксированное время" (если включён, появляется поле выбора времени, например, "07:00", "12:00", "19:00" — можно добавить несколько значений через кнопку "+").
Примеры:
"Каждые 30 минут за 5 часов до дедлайна".
"Каждый день в 07:00 за 14 дней до дедлайна".
"Каждый день в 07:00, 12:00, 19:00 за 7 дней до дедлайна".
Кнопки:
"Отмена": Закрывает окно без сохранения.
"Сохранить": Добавляет задачу в базу данных, отправляет уведомления сотрудникам через Telegram (в зависимости от выбранной опции в "Отправка уведомления" или настроек в "Дополнительная настройка уведомлений") и обновляет страницу.
Модальное окно "Редактирование задачи"
Заголовок: "Редактировать задачу №[task_id]".
Поля: Те же, что в "Добавлении задачи", но заполнены текущими данными задачи. Дополнительно:
Состояние: Выпадающий список "Отправлено", "Принято" или "Выполнено".
Кнопки:
"Отмена": Закрывает окно без изменений.
"Сохранить": Обновляет задачу в базе данных, пересчитывает уведомления (если изменился срок или интервал повторения) и обновляет страницу.
Модальное окно "Статистика задачи"
Заголовок: "Статистика задачи №[task_id]".
Содержимое:
Описание задачи.
Срок выполнения.
Таблица:
Роль: Название роли пользователя (role_group_name) если это роль без подгруппы или role_full_name если есть подгруппа.
ФИО: (user_name)
Статус: "Просрочено" (красный фон), "Выполнено" (зеленый фон), "Принято" (желтый фон), "Отправлено" (без цвета фона).
Дедлайн: Время и дата дедлайна.
Время выполнения: Время и дата завершения или "-".
Кнопка "Закрыть": Закрывает окно.
Модальное окно "Настройка уведомлений"
Заголовок: "Настройка уведомлений для задачи №[task_id]".
Поля:
Список уведомлений: Таблица с текущими запланированными уведомлениями:
Тип: "Создание задачи", "Напоминание", "Дедлайн", "Просрочка", "Повторяющееся".
Время отправки: Дата и время в формате "ЧЧ:ММ ДД.ММ.ГГГГ" или "Сразу" (для уведомлений при создании), или описание частоты (например, "Каждые 30 минут с 07:00 до дедлайна").
Статус: "Запланировано" (серый фон), "Отправлено" (зеленый фон), "Отменено" (красный фон).
Действия: Кнопка "Отменить" (доступна для "Запланировано", отменяет уведомление).
Добавить уведомление:
Тип уведомления: Выпадающий список:
"Напоминание": Уведомление перед дедлайном.
"Дедлайн": Уведомление в момент дедлайна.
"Просрочка": Уведомление после дедлайна (если задача не выполнена).
"Повторяющееся": Уведомление с заданной частотой в заданный период.
Для "Напоминание":
Время: Поле выбора конкретного времени по ЧЧ:ММ ДД:ММ:ГГГГ или выбор "За сколько до дедлайна" (например, "За 5 часов", "За 2 дня") с выпадающим списком единиц (минуты, часы, дни, недели,месяцы).
Для "Дедлайн":
Фиксировано на момент дедлайна задачи (нередактируемое).
Для "Просрочка":
Время: Поле "Ч после дедлайна" (например, "Через 5 часов", "Через 2 дня") с выпадающим списком единиц (минуты, часы, дни, недели,месяцы).
Для "Повторяющееся":
Частота: Выпадающий список: "Каждые n минут", "Каждые n часов", "Каждые n дней" (с полем ввода числа N).
Период: Поля "Начать за" (например, "За 5 часов до дедлайна") и "Закончить" (например, "В момент дедлайна" или "За 2 часа после дедлайна") с единицами (минуты, часы, дни).
Время отправки: Чекбокс "Фиксированное время" (если включён, появляется поле выбора времени, например, "07:00", "12:00", "19:00" — можно добавить несколько значений через кнопку "+").
Примеры:
"Каждые 30 минут за 5 часов до дедлайна".
"Каждый день в 07:00 за 14 дней до дедлайна".
"Каждый день в 07:00, 12:00, 19:00 за 7 дней до дедлайна".
Кнопка "Добавить": Добавляет новое уведомление в список и планирует его через NotificationService.
ДОПОЛНИТЕЛЬНАЯ ЗАМЕТКА:

Для обеспечения отзывчивости интерфейса при большом количестве данных в таблице (например, сотнях задач или ролей) необходимо добавить настраиваемую пагинацию. В нижней части таблицы добавляется блок управления пагинацией с следующими элементами:
Выпадающий список или поле ввода: Позволяет выбрать или вручную ввести количество строк, отображаемых на одной странице (например, 10, 25, 50, 100). Стандартное значение — 25 строк.
Кнопки навигации: "Предыдущая" и "Следующая" для переключения между страницами, а также отображение текущей страницы (например, "Страница 1 из 10"), а также поле где можно ввести нужную страницу.


Вкладка "Роли и пользователи"
Описание
Эта вкладка позволяет управлять ролями и привязанными к ним пользователями (сотрудниками).
Заголовок: "Роли и пользователи".
Фильтры:
Группа: Выпадающий список групп ролей (например, role_group_name).
Поиск по названию: Текстовое поле для фильтрации по полному названию роли.
"Только с пользователями": Чекбокс для отображения ролей с привязанными пользователями.
Кнопка "Добавить роль": Открывает модальное окно для создания новой роли.
Таблица ролей:
Колонки:
№: Порядковый номер для удобства.
ID роли: Уникальный идентификатор (редактируемый).
Роль(role_name):
Название Роли(Редактируемое, обязательное)
Полная Роль(role_full_name): Полное название роли (редактируемое).
Группа(role_group): Группа роли (редактируемая, обязательная).
Подгруппа: Подгруппа роли (редактируемая, необязательная).
Пароль: Пароль для входа в бот (редактируемый).
Пользователи: Список ФИО пользователей(user_name) и в скобочках Telegram ID пользователей с кнопкой "×" для удаления каждого.
Действия: Кнопки "Удалить" и "Сгенерировать новый пароль"(при нажатии на эту кнопку генерируется новый пароль из 7 маленьких латинских букв и/или цифр, а привязанные к роли пользователи автоматически удаляются)
Редактирование: Ячейки (кроме "Пользователи" и "Действия") можно кликнуть для редактирования. После ввода данных изменения сохраняются кнопкой "Сохранить изменения".
Цветовая индикация: Желтый фон для ролей без пользователей.
Кнопка "Сохранить изменения": Сохраняет все отредактированные данные в таблице.
Кнопка "Вернуться на главную": Возвращает на /dashboard.
Функции
Добавление пользователя: Кнопка "Добавить" в столбце "Пользователи" запрашивает Telegram ID (только цифры). После ввода пользователь привязывается к роли, ему отправляется сообщение с паролем через Telegram.
Удаление пользователя: Клик на "×" рядом с Telegram ID отвязывает пользователя от роли после подтверждения.
Удаление роли: Кнопка "Удалить" удаляет роль и все её привязки после подтверждения.
Отправка пароля: Кнопка "Отправить пароль" отправляет текущий пароль всем пользователям роли через Telegram.
Валидация:
ID роли: Только латинские буквы и цифры.
Полное название: Не может быть пустым.
Модальное окно "Добавить роль"
Заголовок: "Добавить роль".
Поля:
ID роли: Текстовое поле (обязательное, только буквы и цифры).
Полное название: Текстовое поле (обязательное).
Группа: Текстовое поле (необязательное).
Подгруппа: Текстовое поле (необязательное).
Кнопки:
"Отмена": Закрывает окно.
"Сохранить": Создаёт роль с автосгенерированным паролем (7 символов из букв и цифр), добавляет её в базу и обновляет страницу.

ДОПОЛНИТЕЛЬНАЯ ЗАМЕТКА:

Для обеспечения отзывчивости интерфейса при большом количестве данных в таблице (например, сотнях задач или ролей) необходимо добавить настраиваемую пагинацию. В нижней части таблицы добавляется блок управления пагинацией с следующими элементами:
Выпадающий список или поле ввода: Позволяет выбрать или вручную ввести количество строк, отображаемых на одной странице (например, 10, 25, 50, 100). Стандартное значение — 25 строк.
Кнопки навигации: "Предыдущая" и "Следующая" для переключения между страницами, а также отображение текущей страницы (например, "Страница 1 из 10"), а также поле где можно ввести нужную страницу.

Вкладка "Динамическое меню"
Описание
Эта вкладка предназначена для управления кнопками Telegram-бота, но в текущей версии реализована минимально (только заглушка).
Элементы интерфейса
Заголовок: "Динамическое меню".
Текст: "Здесь будет таблица кнопок (реализуется позже)."
Функциональность
Пока нет активных элементов. В будущем здесь будет таблица кнопок из buttons_table, с возможностью их редактирования и экспорта в Excel (функция export_buttons_to_excel уже есть в коде).

Вкладка "Рассылка":


Заглушка







Нам нужно:

Объедини все 7 шагов плана исправлений. План исправлений
Шаг 1: Исправление повторения задач
Обновим templates/tasks.html, добавив варианты "Каждые n недель" и "Каждые n месяцев" и динамическое поле ввода n.
Обновим web/tasks.py, чтобы обрабатывать новые единицы.
Добавим JS в static/js/tasks.js для управления полем ввода.
Шаг 2: Исправление настройки уведомлений при добавлении задачи
Обновим templates/tasks.html, добавив блок настройки уведомлений.
Обновим web/tasks.py для обработки всех параметров уведомлений.
Добавим JS в static/js/tasks.js для переключения блока.
Шаг 3: Исправление групп и подгрупп
Обновим templates/tasks.html для отображения групп и подгрупп в фильтре и форме.
Обновим web/tasks.py, маршруты /index, /add, /get_subgroups.
Добавим AJAX в static/js/tasks.js.
Шаг 4: Переименование "Срок" в "Дедлайн"
Обновим templates/tasks.html.
Шаг 5: Гибкая настройка уведомлений в действиях
Обновим templates/tasks.html, модальное окно уведомлений.
Обновим web/tasks.py, маршрут /add_notification.
Добавим JS в static/js/tasks.js.
Шаг 6: Исправление статистики
Обновим templates/tasks_stats.html и web/tasks.py.
Шаг 7: Общие улучшения
Добавим поддержку недель и месяцев везде.
Улучшим пагинацию и JS.

==================================================
Файл: Команды для работы.txt
==================================================

Создать виртуальное пространство
python -m venv venv

Активировать ВП
venv\Scripts\activate

Древо проекта:
tree /f | Out-File -Encoding UTF8 project_structure.txt

Полный код проекта от структуры проекта:
python extract_files.py

Полный код веб интерфейса:
python exweb.py


==================================================
Файл: bot\add_button.py
==================================================

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from utils.database import buttons_table, async_session
from sqlalchemy.future import select
from config import settings
from aiogram.utils.keyboard import InlineKeyboardBuilder
import os

add_button_router = Router()

# Стейты для создания кнопки
class DynamicMenuStates(StatesGroup):
    ADD_BUTTON_DATA = State()
    ADD_BUTTON_COMMAND = State()
    ADD_BUTTON_PARENT = State()
    ADD_BUTTON_NAME = State()
    ADD_BUTTON_TYPE = State()
    ADD_BUTTON_TEXT = State()
    ADD_BUTTON_IMAGE = State()
    ADD_BUTTON_SUBMENUS = State()

# Обработчик кнопки "Добавить кнопку"
@add_button_router.callback_query(F.data == "add_button")
async def start_add_button(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await callback.message.answer(
        "Введите уникальное кодовое имя кнопки (Data):\n"
        "Уникальное имя должно состоять только из латинских букв и/или цифр без пробелов."
    )
    await state.set_state(DynamicMenuStates.ADD_BUTTON_DATA)
    await callback.answer()

# Шаг 1: Ввод уникального кодового имени (Data)
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_DATA)
async def process_data(message: Message, state: FSMContext):
    button_data = message.text.strip()
    
    # Проверяем, не существует ли уже такая запись в базе данных
    async with async_session() as session:
        query = select(buttons_table).where(buttons_table.c.data == button_data)
        result = await session.execute(query)
        if result.fetchone():
            await message.answer("Такое имя уже существует. Введите другое:")
            return

    # Сохраняем данные в состояние пользователя
    await state.update_data({"data": button_data})  # Исправленная строка
    await message.answer(
        "Как будет вызываться кнопка?",
        reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardButton(text="По команде", callback_data="command"),
            InlineKeyboardButton(text="По нажатию в другом меню", callback_data="parent")
        ).as_markup()
    )
    await state.set_state(DynamicMenuStates.ADD_BUTTON_COMMAND)

# Шаг 2: Выбор способа вызова кнопки
@add_button_router.callback_query(DynamicMenuStates.ADD_BUTTON_COMMAND, F.data.in_(["command", "parent"]))
async def process_command(callback: CallbackQuery, state: FSMContext):
    command_type = 1 if callback.data == "command" else 0
    await state.update_data(command=command_type)

    if command_type == 1:  # Вызов по команде
        await callback.message.edit_text("Введите команду для вызова кнопки (без '/'): ")
        await state.set_state(DynamicMenuStates.ADD_BUTTON_PARENT)
    else:  # Вызов через родительскую кнопку
        await callback.message.edit_text("Введите data родительской кнопки:")
        await state.set_state(DynamicMenuStates.ADD_BUTTON_PARENT)

    await callback.answer()

# Шаг 3: Ввод команды или родительской кнопки
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_PARENT)
async def process_parent(message: Message, state: FSMContext):
    parent_data = message.text.strip()
    async with async_session() as session:
        query = select(buttons_table).where(buttons_table.c.data == parent_data)
        result = await session.execute(query)
        if not result.fetchone() and (await state.get_data()).get("command") == 0:
            await message.answer("Родительская кнопка не найдена. Попробуйте еще раз:")
            return

    await state.update_data(parentdataorcommand=parent_data)

    if (await state.get_data()).get("command") == 1:  # Команда
        await state.update_data(name="0")  # Для команд имя всегда "0"
        await message.answer("Выберите тип кнопки:", reply_markup=get_type_keyboard(is_command=True))
        await state.set_state(DynamicMenuStates.ADD_BUTTON_TYPE)
    else:  # Родительская кнопка
        await message.answer("Введите название кнопки:")
        await state.set_state(DynamicMenuStates.ADD_BUTTON_NAME)

# Шаг 4: Ввод названия кнопки
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_NAME)
async def process_name(message: Message, state: FSMContext):
    button_name = message.text.strip()
    await state.update_data(name=button_name)
    await message.answer("Выберите тип кнопки:", reply_markup=get_type_keyboard(is_command=False))
    await state.set_state(DynamicMenuStates.ADD_BUTTON_TYPE)

# Шаг 5: Выбор типа кнопки
@add_button_router.callback_query(DynamicMenuStates.ADD_BUTTON_TYPE, F.data.in_(["menu", "text", "textimage", "url"]))
async def process_type(callback: CallbackQuery, state: FSMContext):
    button_type = callback.data
    await state.update_data(type=button_type)

    if button_type == "menu":
        await callback.message.edit_text("Введите текст, который будет отображаться в меню:")
    elif button_type in ["text", "textimage"]:
        await callback.message.edit_text("Введите текстовое сообщение для кнопки:")
    elif button_type == "url":
        await callback.message.edit_text("Введите URL-ссылку для кнопки:")

    await state.set_state(DynamicMenuStates.ADD_BUTTON_TEXT)
    await callback.answer()

# Шаг 6: Заполнение дополнительных параметров
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_TEXT)
async def process_text(message: Message, state: FSMContext):
    button_text = message.text.strip()
    await state.update_data(text=button_text)

    button_type = (await state.get_data()).get("type")
    if button_type == "menu":
        await message.answer("Введите Data первой подкнопки (или 'Стоп' для завершения):")
        await state.set_state(DynamicMenuStates.ADD_BUTTON_SUBMENUS)
    elif button_type in ["text", "url"]:
        await save_button(message, state)
    elif button_type == "textimage":
        await message.answer("Отправьте изображение, которое будет отображаться:")
        await state.set_state(DynamicMenuStates.ADD_BUTTON_IMAGE)  # Переход к следующему состоянию

# Обработка изображения для кнопки типа textimage
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_IMAGE, F.photo)
async def process_image(message: Message, state: FSMContext):
    from main import bot  # Import here
    # Сохраняем изображение
    file_id = message.photo[-1].file_id
    file = await bot.get_file(file_id)
    file_path = file.file_path

    # Получаем data для названия файла
    state_data = await state.get_data()
    data = state_data["data"]

    # Создаем папку img, если её нет
    if not os.path.exists("img"):
        os.makedirs("img")

    # Сохраняем файл
    destination = f"img/{data}.jpg"
    await bot.download_file(file_path, destination)

    # Сохраняем кнопку
    await save_button(message, state)

# Шаг 7: Создание подменю
@add_button_router.message(DynamicMenuStates.ADD_BUTTON_SUBMENUS)
async def process_submenus(message: Message, state: FSMContext):
    subm_data = message.text.strip().lower()
    if subm_data == "стоп":
        await save_button(message, state)
        return

    state_data = await state.get_data()
    submenus = state_data.get("submenus", [])
    if len(submenus) >= 15:
        await message.answer("Максимальное количество подкнопок достигнуто.")
        await save_button(message, state)
        return

    submenus.append(subm_data)
    await state.update_data(submenus=submenus)
    await message.answer(f"Подкнопка {subm_data} добавлена. Введите следующую (или 'Стоп' для завершения):")

# Сохранение кнопки в базу данных
async def save_button(message: Message, state: FSMContext):
    state_data = await state.get_data()

    async with async_session() as session:
        # Вставляем основные данные кнопки
        query = buttons_table.insert().values(
            data=state_data["data"],
            command=state_data["command"],
            parentdataorcommand=state_data["parentdataorcommand"],
            name=state_data.get("name", ""),
            type=state_data["type"],
            text=state_data.get("text", "")
        )
        await session.execute(query)

        # Обновляем поля подменю
        if state_data.get("submenus"):
            for i, subm in enumerate(state_data["submenus"], start=1):
                update_query = (
                    buttons_table.update().
                    where(buttons_table.c.data == state_data["data"]).
                    values(**{f"submdata{i}": subm})
                )
                await session.execute(update_query)

        await session.commit()

    # Формируем уведомление об успешном добавлении
    command = "По команде" if state_data["command"] == 1 else "По нажатию в другом меню"
    response = f"Кнопка успешно добавлена!\nТип вызова: {command}\n"

    if state_data["command"] == 1:
        response += f"Команда: /{state_data['parentdataorcommand']}\n"
    else:
        response += f"Родительская кнопка: {state_data['parentdataorcommand']}\nНазвание кнопки: {state_data['name']}\n"

    response += f"Тип кнопки: {state_data['type'].capitalize()}\n"

    if state_data["type"] == "menu":
        submenus = state_data.get("submenus", [])
        response += "Подменю:\n"
        for i, subm in enumerate(submenus, start=1):
            response += f"  {i}. Data дочерней кнопки: {subm}\n"
    elif state_data["type"] in ["text", "textimage"]:
        response += f"Текст сообщения: {state_data['text']}\n"
        if state_data["type"] == "textimage":
            response += f"Изображение сохранено как: {state_data['data']}.jpg\n"
    elif state_data["type"] == "url":
        response += f"Ссылка: {state_data['text']}\n"

    await message.answer(response)
    await state.clear()
    
    # Перенаправляем администратора обратно в динамическое меню
    from bot.adminpanel import DYNAMIC_MENU  # Import here to avoid circular imports
    await message.answer(
        "Вы можете продолжить настройку динамического меню:",
        reply_markup=DYNAMIC_MENU
    )



# Функция для создания клавиатуры выбора типа кнопки
def get_type_keyboard(is_command: bool):
    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="Меню", callback_data="menu"),
        InlineKeyboardButton(text="Текст", callback_data="text"),
        InlineKeyboardButton(text="Текст + Картинка", callback_data="textimage")
    )
    if not is_command:
        keyboard.row(
            InlineKeyboardButton(text="URL (ссылка)", callback_data="url")
        )
    return keyboard.as_markup()

==================================================
Файл: bot\adminpanel.py
==================================================

from aiogram import Router, F
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, Message, BufferedInputFile
from bot.add_button import add_button_router
from bot.edit_button import edit_button_router
from config import settings
from bot.view_buttons import view_buttons_router, show_buttons
from utils.export_excel import export_buttons_to_excel  # Для скачивания Excel

adminpanel_router = Router()

ADMIN_MENU = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="Динамическое меню", callback_data="dynamic_menu")],
    [InlineKeyboardButton(text="В главное меню", callback_data="back_to_start")],
])

DYNAMIC_MENU = InlineKeyboardMarkup(inline_keyboard=[
    [InlineKeyboardButton(text="Просмотреть кнопки", callback_data="view_buttons")],
    [InlineKeyboardButton(text="Добавить кнопку", callback_data="add_button")],
    [InlineKeyboardButton(text="Редактировать кнопку", callback_data="edit_button")],
    [InlineKeyboardButton(text="Скачать Excel", callback_data="download_excel")],
    [InlineKeyboardButton(text="Назад", callback_data="back_to_admin_menu")],
])

@adminpanel_router.callback_query(F.data == "view_buttons")
async def handle_view_buttons(callback: CallbackQuery):
    await show_buttons(callback)  # Вызываем функцию из view_buttons.py

# Обработчик команды /admin
@adminpanel_router.message(F.text == "/admin")
async def admin_panel(message: Message):
    if message.from_user.id not in settings.ADMIN_IDS:
        await message.answer("У вас нет прав администратора.")
        return

    await message.delete()
    await message.answer("Выберите действие:", reply_markup=ADMIN_MENU)

# Обработчик кнопки Динамическое меню
@adminpanel_router.callback_query(F.data == "dynamic_menu")
async def manage_dynamic_menu(callback: CallbackQuery):
    await callback.message.edit_text(
        "Вы можете управлять динамическим меню:",
        reply_markup=DYNAMIC_MENU
    )
    await callback.answer()

# Функция Скачать Excel
@adminpanel_router.callback_query(F.data == "download_excel")
async def download_excel(callback: CallbackQuery):
    if callback.from_user.id not in settings.ADMIN_IDS:
        await callback.message.answer("У вас нет прав администратора.")
        return

    try:
        # Удаляем текущее сообщение с меню
        await callback.message.delete()

        # Генерируем и отправляем Excel-файл
        excel_file = await export_buttons_to_excel()
        if excel_file:
            input_file = BufferedInputFile(excel_file.getvalue(), filename="buttons.xlsx")
            await callback.message.answer_document(
                document=input_file,
                caption="Полный список кнопок из базы данных."
            )
        else:
            await callback.message.answer("База данных пуста.")

        # Повторно отображаем динамическое меню
        await callback.message.answer(
            "Вы можете управлять динамическим меню:",
            reply_markup=DYNAMIC_MENU
        )

    except Exception as e:
        await callback.message.answer(f"Произошла ошибка: {e}")
    finally:
        await callback.answer()

@adminpanel_router.callback_query(F.data == "back_to_admin_menu")
async def back_to_admin_menu(callback: CallbackQuery):
    await callback.message.edit_text("С возвращением в админ-панель!", reply_markup=ADMIN_MENU)
    await callback.answer()

adminpanel_router.include_router(add_button_router)
adminpanel_router.include_router(edit_button_router)
adminpanel_router.include_router(view_buttons_router)

==================================================
Файл: bot\basic_handlers.py
==================================================

# bot/basic_handlers.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from utils.database import get_role_by_password, bind_user_to_role, get_user_role, get_role_by_id, unbind_user_from_role, get_tasks, update_task_status, get_button_by_data, add_task_completion
from datetime import datetime

router = Router()

# Состояния для FSM
class AuthState(StatesGroup):
    waiting_for_password = State()

class TaskState(StatesGroup):
    viewing_tasks = State()

class ChangeRoleState(StatesGroup):
    confirming = State()

# Главное меню
def get_main_menu(role_group: str):
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Задачи", callback_data="tasks")],
        [InlineKeyboardButton(text="Динамическое меню", callback_data=role_group or "menu")],
        [InlineKeyboardButton(text="Сменить роль", callback_data="change_role")]
    ])

# Обработчик команды /start
@router.message(F.text == "/start")
async def cmd_start(message: Message, state: FSMContext):
    user_id = str(message.from_user.id)
    role_user = await get_user_role(user_id)
    
    if role_user:
        role = await get_role_by_id(role_user.role_id)
        await message.answer(
            f"Добро пожаловать, {role.role_full_name}! Вот ваше меню:",
            reply_markup=get_main_menu(role.role_group)
        )
    else:
        await message.answer("Введите пароль для входа:")
        await state.set_state(AuthState.waiting_for_password)

# Обработчик ввода пароля
@router.message(AuthState.waiting_for_password)
async def process_password(message: Message, state: FSMContext):
    password = message.text.strip()
    role = await get_role_by_password(password)
    if role:
        user_id = str(message.from_user.id)
        await bind_user_to_role(user_id, role.role_id)
        await message.answer(
            f"Вы вошли как {role.role_full_name}. Вот ваше меню:",
            reply_markup=get_main_menu(role.role_group)
        )
        await state.clear()
    else:
        await message.answer("Введён неверный пароль. Попробуйте снова:")

# Обработчик выбора "Задачи"
@router.callback_query(F.data == "tasks")
async def show_task_categories(callback: CallbackQuery, state: FSMContext):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Личные задачи", callback_data="tasks_personal")],
        [InlineKeyboardButton(text="Задачи для роли", callback_data="tasks_role")],
        [InlineKeyboardButton(text="Общие задачи", callback_data="tasks_all")],
        [InlineKeyboardButton(text="Назад", callback_data="back_to_main")]
    ])
    await callback.message.edit_text("Выберите категорию задач:", reply_markup=keyboard)
    await state.set_state(TaskState.viewing_tasks)
    await callback.answer()

# Отображение задач
@router.callback_query(TaskState.viewing_tasks, F.data.startswith("tasks_"))
async def show_tasks(callback: CallbackQuery, state: FSMContext):
    user_id = str(callback.from_user.id)
    role_user = await get_user_role(user_id)
    if not role_user:
        await callback.message.edit_text("Вы не авторизованы. Введите /start для входа.")
        await callback.answer()
        return
    
    role = await get_role_by_id(role_user.role_id)
    category = callback.data.split("_")[1]
    
    tasks = []
    if category == "personal":
        tasks = await get_tasks(role_id=role.role_id)
        tasks = [t for t in tasks if t.role_id == role.role_id]
        title = "Личные задачи"
    elif category == "role" and role.role_group:
        tasks = await get_tasks(role_group=role.role_group)
        tasks = [t for t in tasks if t.role_id == role.role_group]
        title = f"Задачи для роли ({role.role_group})"
    elif category == "all":
        tasks = await get_tasks(all_tasks=True)
        title = "Общие задачи"

    # Сохраняем данные в состоянии
    await state.update_data(tasks=tasks, category=category, title=title, show_completed=False)
    
    # Показываем невыполненные задачи
    incomplete_tasks = [t for t in tasks if t.status != "completed"]
    
    if not incomplete_tasks:
        text = f"{title} (невыполненные):\nНет невыполненных задач."
    else:
        text = f"{title} (невыполненные):\n" + "\n".join(f"#{t.task_id} {t.description}" for t in incomplete_tasks)

    keyboard = InlineKeyboardBuilder()
    for task in incomplete_tasks:
        keyboard.row(InlineKeyboardButton(text=f"Выполнить #{task.task_id}", callback_data=f"complete_{task.task_id}"))
    keyboard.row(InlineKeyboardButton(text="Показать выполненные", callback_data="show_completed"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="tasks"))
    
    await callback.message.edit_text(text, reply_markup=keyboard.as_markup())
    await callback.answer()

# Показать выполненные задачи
@router.callback_query(TaskState.viewing_tasks, F.data == "show_completed")
async def show_completed_tasks(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    tasks = data["tasks"]
    title = data["title"]
    
    completed_tasks = [t for t in tasks if t.status == "completed"]
    
    if not completed_tasks:
        text = f"{title} (выполненные):\nНет выполненных задач."
    else:
        text = f"{title} (выполненные):\n" + "\n".join(f"#{t.task_id} {t.description}" for t in completed_tasks)

    keyboard = InlineKeyboardBuilder()
    for task in completed_tasks:
        keyboard.row(InlineKeyboardButton(text=f"Отменить #{task.task_id}", callback_data=f"undo_{task.task_id}"))
    keyboard.row(InlineKeyboardButton(text="Невыполненные задачи", callback_data="hide_completed"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="tasks"))
    
    await callback.message.edit_text(text, reply_markup=keyboard.as_markup())
    await state.update_data(show_completed=True)
    await callback.answer()

# Скрыть выполненные задачи
@router.callback_query(TaskState.viewing_tasks, F.data == "hide_completed")
async def hide_completed_tasks(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    tasks = data["tasks"]
    title = data["title"]
    
    incomplete_tasks = [t for t in tasks if t.status != "completed"]
    
    if not incomplete_tasks:
        text = f"{title} (невыполненные):\nНет невыполненных задач."
    else:
        text = f"{title} (невыполненные):\n" + "\n".join(f"#{t.task_id} {t.description}" for t in incomplete_tasks)

    keyboard = InlineKeyboardBuilder()
    for task in incomplete_tasks:
        keyboard.row(InlineKeyboardButton(text=f"Выполнить #{task.task_id}", callback_data=f"complete_{task.task_id}"))
    keyboard.row(InlineKeyboardButton(text="Показать выполненные", callback_data="show_completed"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="tasks"))
    
    await callback.message.edit_text(text, reply_markup=keyboard.as_markup())
    await state.update_data(show_completed=False)
    await callback.answer()

# Отметить задачу выполненной
@router.callback_query(TaskState.viewing_tasks, F.data.startswith("complete_"))
async def complete_task(callback: CallbackQuery, state: FSMContext):
    task_id = int(callback.data.split("_")[1])
    user_id = str(callback.from_user.id)
    await add_task_completion(task_id, user_id, "completed", datetime.now())
    await update_task_status(task_id, "completed")  # Синхронизация с tasks_table
    
    # Обновляем список задач
    await hide_completed_tasks(callback, state)
    await callback.answer(f"Задача #{task_id} отмечена как выполненная.")

# Отменить выполнение задачи
@router.callback_query(TaskState.viewing_tasks, F.data.startswith("undo_"))
async def undo_task(callback: CallbackQuery, state: FSMContext):
    task_id = int(callback.data.split("_")[1])
    user_id = str(callback.from_user.id)
    await add_task_completion(task_id, user_id, "accepted", None)
    await update_task_status(task_id, "accepted")  # Синхронизация с tasks_table
    
    # Обновляем список задач
    await show_completed_tasks(callback, state)
    await callback.answer(f"Статус задачи #{task_id} изменён на 'принято'.")

# Возврат в главное меню
@router.callback_query(F.data == "back_to_main")
async def back_to_main(callback: CallbackQuery, state: FSMContext):
    user_id = str(callback.from_user.id)
    role_user = await get_user_role(user_id)
    if not role_user:
        await callback.message.edit_text("Вы не авторизованы. Введите /start для входа.")
        await callback.answer()
        return
    
    role = await get_role_by_id(role_user.role_id)
    await callback.message.edit_text(
        f"Добро пожаловать, {role.role_full_name}! Вот ваше меню:",
        reply_markup=get_main_menu(role.role_group)
    )
    await state.clear()
    await callback.answer()

# Динамическое меню
@router.callback_query(lambda c: c.data in ["voz", "menu"])
async def process_dynamic_menu(callback: CallbackQuery):
    user_id = str(callback.from_user.id)
    role_user = await get_user_role(user_id)
    if not role_user:
        await callback.message.edit_text("Вы не авторизованы. Введите /start для входа.")
        await callback.answer()
        return
    
    role = await get_role_by_id(role_user.role_id)
    button = await get_button_by_data(role.role_group or "menu")
    
    if not button:
        await callback.message.edit_text("Динамическое меню для вашей роли не настроено.")
        await callback.answer()
        return
    
    await show_dynamic_menu(callback, button)

@router.callback_query(F.data.startswith("btn_"))
async def process_dynamic_button(callback: CallbackQuery):
    button_data = callback.data.split("_")[1]
    button = await get_button_by_data(button_data)
    
    if not button:
        await callback.message.edit_text("Кнопка не найдена.")
        await callback.answer()
        return
    
    if button.type == "menu":
        await show_dynamic_menu(callback, button)
    elif button.type == "text":
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Назад", callback_data=f"btn_{button.parentdataorcommand}")]
        ])
        await callback.message.edit_text(button.text, reply_markup=keyboard)
        await callback.answer()
    elif button.type == "url":
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=button.name, url=button.text)],
            [InlineKeyboardButton(text="Назад", callback_data=f"btn_{button.parentdataorcommand}")]
        ])
        await callback.message.edit_text("Перейдите по ссылке:", reply_markup=keyboard)
        await callback.answer()

async def show_dynamic_menu(callback: CallbackQuery, button):
    keyboard = InlineKeyboardBuilder()
    for i in range(1, 16):
        submdata = getattr(button, f"submdata{i}", None)
        if submdata and submdata != "0":
            sub_button = await get_button_by_data(submdata)
            if sub_button:
                if sub_button.type == "url":
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, url=sub_button.text))
                else:
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, callback_data=f"btn_{submdata}"))
    
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="back_to_main"))
    await callback.message.edit_text(button.text or "Динамическое меню", reply_markup=keyboard.as_markup())
    await callback.answer()

# Смена роли
@router.callback_query(F.data == "change_role")
async def process_change_role(callback: CallbackQuery, state: FSMContext):
    user_id = str(callback.from_user.id)
    role_user = await get_user_role(user_id)
    if not role_user:
        await callback.message.edit_text("Вы не авторизованы. Введите /start для входа.")
        await callback.answer()
        return
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Да", callback_data="confirm_change_role")],
        [InlineKeyboardButton(text="Нет", callback_data="back_to_main")]
    ])
    await callback.message.edit_text(
        "Вы действительно хотите покинуть свою роль? Вы не сможете вернуться без повторного ввода пароля.",
        reply_markup=keyboard
    )
    await state.set_state(ChangeRoleState.confirming)
    await callback.answer()

@router.callback_query(F.data == "confirm_change_role", ChangeRoleState.confirming)
async def confirm_change_role(callback: CallbackQuery, state: FSMContext):
    user_id = str(callback.from_user.id)
    await unbind_user_from_role(user_id)
    await callback.message.edit_text("Вы покинули свою роль. Введите /start для новой авторизации.")
    await state.clear()
    await callback.answer()

==================================================
Файл: bot\edit_button.py
==================================================

# bot/edit_button.py

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from utils.database import buttons_table, async_session
from sqlalchemy.future import select
from aiogram.utils.keyboard import InlineKeyboardBuilder
import logging

logging.basicConfig(level=logging.INFO)

edit_button_router = Router()

class EditButtonStates(StatesGroup):
    SELECT_BUTTON = State()
    SELECT_PARAMETER = State()
    EDIT_DATA = State()
    EDIT_COMMAND = State()
    EDIT_PARENT = State()
    EDIT_NAME = State()
    EDIT_TYPE = State()
    EDIT_TEXT = State()
    EDIT_IMAGE = State()
    EDIT_SUBMENU = State()
    ADD_SUBBUTTON = State()
    DELETE_SUBBUTTON = State()
    CONFIRM_CHANGES = State()

@edit_button_router.callback_query(F.data == "back_to_edit_params")
async def back_to_edit_params(callback: CallbackQuery, state: FSMContext):
    await show_current_parameters(callback.message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)
    await callback.answer()

async def confirm_changes(message: Message, state: FSMContext):
    logging.info("Entering confirm_changes")
    data = await state.get_data()
    button = data['original_button']
    pending_updates = data.get('pending_updates', {})
    
    updated_button = dict(button)
    updated_button.update(pending_updates)
    
    text = (
        "Вы уверены, что хотите сохранить изменения?\n\n"
        f"Новые параметры:\n"
        f"Data: {updated_button['data']}\n"
        f"Способ вызова: {'По команде' if updated_button['command'] == 1 else 'По нажатию'}\n"
        f"Родительская кнопка/Команда: {updated_button['parentdataorcommand']}\n"
        f"Название: {updated_button['name']}\n"
        f"Тип: {updated_button['type']}\n"
        f"Текст/Ссылка: {updated_button['text']}\n"
    )
    
    if updated_button['type'] == 'menu':
        submenus = [updated_button.get(f"submdata{i}") for i in range(1, 16) if updated_button.get(f"submdata{i}", None)]
        text += "Подменю:\n" + "\n".join([f"{i+1}. {sub}" for i, sub in enumerate(submenus)])
    
    keyboard = InlineKeyboardBuilder()
    keyboard.row(
        InlineKeyboardButton(text="Сохранить", callback_data="save_changes"),
        InlineKeyboardButton(text="Отменить", callback_data="cancel_changes")
    )
    logging.info("Sending confirmation message")
    await message.answer(text, reply_markup=keyboard.as_markup())
    await state.set_state(EditButtonStates.CONFIRM_CHANGES)
    logging.info("Confirmation message sent, state set to CONFIRM_CHANGES")

@edit_button_router.callback_query(F.data == "save_changes")
async def save_changes(callback: CallbackQuery, state: FSMContext):
    from main import bot
    chat_id = callback.message.chat.id
    logging.info(f"Starting save_changes for chat {chat_id}, current state: {await state.get_state()}")
    try:
        logging.info(f"Attempting to delete message in chat {chat_id}")
        await callback.message.delete()
        logging.info("Message deleted successfully")
        await state.update_data(pending_updates={})  # Очищаем временные изменения
        logging.info(f"Sending 'Changes saved' to chat {chat_id}")
        await bot.send_message(chat_id, "Изменения успешно сохранены!")
        
        # Получаем актуальные данные из базы после сохранения
        logging.info("Fetching updated button data from database")
        data = await state.get_data()
        button_data = data['button_data']
        button_row = await get_button_by_data(button_data)  # Получаем актуальные данные
        button = button_row._mapping if button_row else data['original_button']  # Используем базу или старые данные
        await state.update_data(original_button=button)  # Обновляем original_button в состоянии
        
        # Показываем актуальные параметры
        text = (
            f"Текущие параметры кнопки:\n"
            f"Data: {button['data']}\n"
            f"Способ вызова: {'По команде' if button['command'] == 1 else 'По нажатию в другом меню'}\n"
            f"Родительская кнопка/Команда: {button['parentdataorcommand']}\n"
            f"Название: {button['name']}\n"
            f"Тип: {button['type']}\n"
            f"Текст/Ссылка: {button['text']}\n"
        )
        if button['type'] == 'menu':
            submenus = [button.get(f"submdata{i}") for i in range(1, 16) if button.get(f"submdata{i}", None)]
            text += "Подменю:\n" + "\n".join([f"{i+1}. {sub}" for i, sub in enumerate(submenus)])
        keyboard = InlineKeyboardBuilder()
        keyboard.row(InlineKeyboardButton(text="Data(уникальное имя)", callback_data="edit_data"))
        keyboard.row(InlineKeyboardButton(text="Способ вызова", callback_data="edit_command"))
        keyboard.row(InlineKeyboardButton(text="Родительская кнопка/Команда", callback_data="edit_parent"))
        keyboard.row(
            InlineKeyboardButton(text="Название", callback_data="edit_name"),
            InlineKeyboardButton(text="Тип", callback_data="edit_type")
        )
        keyboard.row(InlineKeyboardButton(text="Текст/Ссылка", callback_data="edit_text"))
        if button['type'] == 'textimage':
            keyboard.row(InlineKeyboardButton(text="Изображение", callback_data="edit_image"))
        if button['type'] == 'menu':
            keyboard.row(InlineKeyboardButton(text="Подменю", callback_data="edit_submenu"))
        keyboard.row(InlineKeyboardButton(text="Назад", callback_data="back_to_dynamic_menu"))
        logging.info(f"Sending updated parameters to chat {chat_id}")
        await bot.send_message(chat_id, text, reply_markup=keyboard.as_markup())
        logging.info("Save_changes completed successfully")
        await callback.answer("Изменения сохранены успешно")
    except Exception as e:
        logging.error(f"Error in save_changes: {e}")
        await callback.answer(f"Ошибка при сохранении: {e}", show_alert=True)
    

@edit_button_router.callback_query(F.data == "cancel_changes")
async def cancel_changes(callback: CallbackQuery, state: FSMContext):
    from main import bot
    chat_id = callback.message.chat.id
    logging.info(f"Starting cancel_changes for chat {chat_id}, current state: {await state.get_state()}")
    try:
        logging.info(f"Attempting to delete message in chat {chat_id}")
        await callback.message.delete()
        logging.info("Message deleted successfully")
        
        # Получаем данные из состояния
        data = await state.get_data()
        button_data = data['button_data']
        original_button = data['original_button']  # Исходное состояние кнопки
        pending_updates = data.get('pending_updates', {})
        
        # Откатываем изменения в базе, возвращая исходное состояние
        if pending_updates:
            async with async_session() as session:
                # Формируем запрос на обновление, возвращая исходные данные
                query = (
                    buttons_table.update().
                    where(buttons_table.c.data == button_data).
                    values(**original_button)  # Восстанавливаем исходное состояние
                )
                await session.execute(query)
                await session.commit()
                logging.info(f"Changes rolled back in database for button {button_data}")
        
        await state.update_data(pending_updates={})
        logging.info(f"Sending 'Changes cancelled' to chat {chat_id}")
        await bot.send_message(chat_id, "Изменения отменены.")
        
        # Показываем текущее состояние кнопки (должно быть без a12)
        button = original_button  # Используем исходное состояние
        text = (
            f"Текущие параметры кнопки:\n"
            f"Data: {button['data']}\n"
            f"Способ вызова: {'По команде' if button['command'] == 1 else 'По нажатию в другом меню'}\n"
            f"Родительская кнопка/Команда: {button['parentdataorcommand']}\n"
            f"Название: {button['name']}\n"
            f"Тип: {button['type']}\n"
            f"Текст/Ссылка: {button['text']}\n"
        )
        if button['type'] == 'menu':
            submenus = [button.get(f"submdata{i}") for i in range(1, 16) if button.get(f"submdata{i}", None)]
            text += "Подменю:\n" + "\n".join([f"{i+1}. {sub}" for i, sub in enumerate(submenus)])
        keyboard = InlineKeyboardBuilder()
        keyboard.row(InlineKeyboardButton(text="Data(уникальное имя)", callback_data="edit_data"))
        keyboard.row(InlineKeyboardButton(text="Способ вызова", callback_data="edit_command"))
        keyboard.row(InlineKeyboardButton(text="Родительская кнопка/Команда", callback_data="edit_parent"))
        keyboard.row(
            InlineKeyboardButton(text="Название", callback_data="edit_name"),
            InlineKeyboardButton(text="Тип", callback_data="edit_type")
        )
        keyboard.row(InlineKeyboardButton(text="Текст/Ссылка", callback_data="edit_text"))
        if button['type'] == 'textimage':
            keyboard.row(InlineKeyboardButton(text="Изображение", callback_data="edit_image"))
        if button['type'] == 'menu':
            keyboard.row(InlineKeyboardButton(text="Подменю", callback_data="edit_submenu"))
        keyboard.row(InlineKeyboardButton(text="Назад", callback_data="back_to_dynamic_menu"))
        logging.info(f"Sending current parameters to chat {chat_id}")
        await bot.send_message(chat_id, text, reply_markup=keyboard.as_markup())
        logging.info("Cancel_changes completed successfully")
        await callback.answer("Изменения отменены успешно")
    except Exception as e:
        logging.error(f"Error in cancel_changes: {e}")
        await callback.answer(f"Ошибка при отмене: {e}", show_alert=True)

@edit_button_router.callback_query(F.data == "edit_button")
async def start_edit_button(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await callback.message.answer(
        "Редактировать можно только существующие кнопки. "
        "Введите уникальное кодовое имя кнопки (Data), которую хотите отредактировать:\n"
        "Чтобы вернуться назад, нажмите кнопку 'Назад'.",
        reply_markup=InlineKeyboardBuilder().row(
            InlineKeyboardButton(text="Назад", callback_data="back_to_dynamic_menu")
        ).as_markup()
    )
    await state.set_state(EditButtonStates.SELECT_BUTTON)

@edit_button_router.callback_query(F.data == "back_to_dynamic_menu")
async def back_to_dynamic_menu(callback: CallbackQuery):
    await callback.message.edit_text(
        "Вы можете управлять динамическим меню:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Просмотреть кнопки", callback_data="view_buttons")],
            [InlineKeyboardButton(text="Добавить кнопку", callback_data="add_button")],
            [InlineKeyboardButton(text="Редактировать кнопку", callback_data="edit_button")],
            [InlineKeyboardButton(text="Удалить кнопку", callback_data="delete_button")],
            [InlineKeyboardButton(text="Назад", callback_data="back_to_admin_menu")]
        ])
    )
    await callback.answer()

@edit_button_router.message(EditButtonStates.SELECT_BUTTON, ~F.text.startswith('/'))
async def select_button(message: Message, state: FSMContext):
    button_data = message.text.strip()
    button = await get_button_by_data(button_data)
    
    if not button:
        await message.answer("Кнопка с таким именем не найдена. Попробуйте еще раз.")
        return
    
    await state.update_data(button_data=button_data, original_button=button._mapping)
    await show_current_parameters(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.message(EditButtonStates.SELECT_BUTTON, F.text.startswith('/'))
async def handle_commands_in_select_button(message: Message, state: FSMContext):
    await message.answer(
        "Пожалуйста, введите уникальное кодовое имя кнопки (Data) без использования команд (например, без '/').\n"
        "Если вы хотите выйти, используйте кнопку 'Назад'."
    )

async def show_current_parameters(message: Message, state: FSMContext):
    data = await state.get_data()
    button = data['original_button']
    
    text = (
        f"Текущие параметры кнопки:\n"
        f"Data: {button['data']}\n"
        f"Способ вызова: {'По команде' if button['command'] == 1 else 'По нажатию в другом меню'}\n"
        f"Родительская кнопка/Команда: {button['parentdataorcommand']}\n"
        f"Название: {button['name']}\n"
        f"Тип: {button['type']}\n"
        f"Текст/Ссылка: {button['text']}\n"
    )
    
    if button['type'] == 'menu':
        submenus = [getattr(button, f"submdata{i}") for i in range(1, 16) if getattr(button, f"submdata{i}", None)]
        text += "Подменю:\n" + "\n".join([f"{i+1}. {sub}" for i, sub in enumerate(submenus)])
    
    keyboard = InlineKeyboardBuilder()
    keyboard.row(InlineKeyboardButton(text="Data(уникальное имя)", callback_data="edit_data"))
    keyboard.row(InlineKeyboardButton(text="Способ вызова", callback_data="edit_command"))
    keyboard.row(InlineKeyboardButton(text="Родительская кнопка/Команда", callback_data="edit_parent"))
    keyboard.row(
        InlineKeyboardButton(text="Название", callback_data="edit_name"),
        InlineKeyboardButton(text="Тип", callback_data="edit_type")
    )
    keyboard.row(InlineKeyboardButton(text="Текст/Ссылка", callback_data="edit_text"))
    if button['type'] == 'textimage':
        keyboard.row(InlineKeyboardButton(text="Изображение", callback_data="edit_image"))
    if button['type'] == 'menu':
        keyboard.row(InlineKeyboardButton(text="Подменю", callback_data="edit_submenu"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="back_to_dynamic_menu"))
    
    await message.answer(text, reply_markup=keyboard.as_markup())

@edit_button_router.callback_query(F.data == "back_to_edit_params")
async def back_to_edit_params(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await state.clear()
    await show_current_parameters(callback.message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)
    await callback.answer()

@edit_button_router.callback_query(EditButtonStates.SELECT_PARAMETER, F.data.startswith("edit_"))
async def edit_parameter(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    parameter = callback.data.split("_")[1]

    keyboard = InlineKeyboardBuilder()
    keyboard.row(InlineKeyboardButton(text="Отмена", callback_data="back_to_edit_params"))

    if parameter == "data":
        await callback.message.answer(
            "Уникальное имя должно состоять только из латинских букв и/или цифр без пробелов.\n"
            "Введите новое уникальное кодовое имя кнопки (Data) или вернитесь назад.",
            reply_markup=keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_DATA)
    elif parameter == "command":
        await callback.message.answer(
            "Выберите новый способ вызова:",
            reply_markup=InlineKeyboardBuilder().row(
                InlineKeyboardButton(text="По команде", callback_data="command_1"),
                InlineKeyboardButton(text="По нажатию в другом меню", callback_data="command_0"),
                InlineKeyboardButton(text="Отмена", callback_data="back_to_edit_params")
            ).as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_COMMAND)
    elif parameter == "parent":
        await callback.message.answer(
            "Введите новое значение родительской кнопки/команды или вернитесь назад.",
            reply_markup=keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_PARENT)
    elif parameter == "name":
        await callback.message.answer(
            "Введите новое название кнопки или вернитесь назад.",
            reply_markup=keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_NAME)
    elif parameter == "type":
        data = await state.get_data()
        command = data['original_button']['command']
        
        type_keyboard = InlineKeyboardBuilder()
        if command == 0:
            type_keyboard.row(InlineKeyboardButton(text="Меню", callback_data="type_menu"))
            type_keyboard.row(InlineKeyboardButton(text="Текст", callback_data="type_text"))
            type_keyboard.row(InlineKeyboardButton(text="Текст + Картинка", callback_data="type_textimage"))
            type_keyboard.row(InlineKeyboardButton(text="URL (ссылка)", callback_data="type_url"))
        else:
            type_keyboard.row(InlineKeyboardButton(text="Меню", callback_data="type_menu"))
            type_keyboard.row(InlineKeyboardButton(text="Текст", callback_data="type_text"))
            type_keyboard.row(InlineKeyboardButton(text="Текст + Картинка", callback_data="type_textimage"))
        
        type_keyboard.row(InlineKeyboardButton(text="Отмена", callback_data="back_to_edit_params"))
        
        await callback.message.answer(
            "Выберите новый тип кнопки или вернитесь назад.",
            reply_markup=type_keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_TYPE)
    elif parameter == "text":
        await callback.message.answer(
            "Введите новый текст / новую ссылку или вернитесь назад.",
            reply_markup=keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_TEXT)
    elif parameter == "image":
        await callback.message.answer(
            "Отправьте новое изображение или вернитесь назад.",
            reply_markup=keyboard.as_markup()
        )
        await state.set_state(EditButtonStates.EDIT_IMAGE)
    elif parameter == "submenu":
        await edit_submenu(callback, state)
    
    await callback.answer()

@edit_button_router.message(EditButtonStates.EDIT_DATA)
async def process_edit_data(message: Message, state: FSMContext):
    new_data = message.text.strip()
    updates = {"data": new_data}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await message.answer(f"Data изменено на {new_data}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.callback_query(EditButtonStates.EDIT_COMMAND, F.data.startswith("command_"))
async def process_edit_command(callback: CallbackQuery, state: FSMContext):
    command = int(callback.data.split("_")[1])
    updates = {"command": command}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await callback.message.answer(f"Способ вызова изменен на {'По команде' if command == 1 else 'По нажатию'}.")
    await confirm_changes(callback.message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)
    await callback.answer()

@edit_button_router.message(EditButtonStates.EDIT_PARENT)
async def process_edit_parent(message: Message, state: FSMContext):
    parent = message.text.strip()
    updates = {"parentdataorcommand": parent}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await message.answer(f"Родительская кнопка/команда изменена на {parent}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.message(EditButtonStates.EDIT_NAME)
async def process_edit_name(message: Message, state: FSMContext):
    name = message.text.strip()
    updates = {"name": name}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await message.answer(f"Название изменено на {name}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.callback_query(EditButtonStates.EDIT_TYPE, F.data.startswith("type_"))
async def process_edit_type(callback: CallbackQuery, state: FSMContext):
    button_type = callback.data.split("_")[1]
    updates = {"type": button_type}

    if button_type != "menu":
        for i in range(1, 16):
            updates[f"submdata{i}"] = "0"

    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await callback.message.answer(f"Тип изменен на {button_type}.")
    await confirm_changes(callback.message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)
    await callback.answer()

@edit_button_router.message(EditButtonStates.EDIT_TEXT)
async def process_edit_text(message: Message, state: FSMContext):
    text = message.text.strip()
    updates = {"text": text}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    await message.answer(f"Текст/ссылка изменены на {text}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.message(EditButtonStates.EDIT_IMAGE)
async def process_edit_image(message: Message, state: FSMContext):
    if not message.photo:
        await message.answer("Пожалуйста, отправьте изображение.")
        return

    from main import bot
    try:
        file_id = message.photo[-1].file_id
        file = await bot.get_file(file_id)
        file_path = file.file_path
        data = await state.get_data()
        destination = f"img/{data['button_data']}.jpg"
        await bot.download_file(file_path, destination)
        updates = {}
        await state.update_data(pending_updates=updates)
        await message.answer("Изображение обновлено.")
        await confirm_changes(message, state)
        await state.set_state(EditButtonStates.SELECT_PARAMETER)
    except Exception as e:
        await message.answer(f"Произошла ошибка: {e}")

@edit_button_router.callback_query(EditButtonStates.SELECT_PARAMETER, F.data == "edit_submenu")
async def edit_submenu(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    button = data['original_button']
    
    submenus = [getattr(button, f"submdata{i}") for i in range(1, 16) if getattr(button, f"submdata{i}", None)]
    text = "Выберите подкнопку для редактирования или выполните действие:\n" if submenus else "Подменю пусто. Добавьте подкнопку:\n"
    
    keyboard = InlineKeyboardBuilder()
    for i, sub in enumerate(submenus, start=1):
        keyboard.row(InlineKeyboardButton(text=f"{i}. {sub}", callback_data=f"edit_sub:{sub}"))
    
    keyboard.row(InlineKeyboardButton(text="Добавить подкнопку", callback_data="add_subbutton"))
    if submenus:
        keyboard.row(InlineKeyboardButton(text="Удалить подкнопку", callback_data="delete_subbutton"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="back_to_edit_params"))
    
    await callback.message.answer(text, reply_markup=keyboard.as_markup())
    await callback.answer()

@edit_button_router.callback_query(F.data.startswith("edit_sub:"))
async def edit_subbutton(callback: CallbackQuery, state: FSMContext):
    subbutton_data = callback.data.split(":")[1]
    await state.update_data(selected_subbutton=subbutton_data)
    
    keyboard = InlineKeyboardBuilder()
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="edit_submenu"))
    
    await callback.message.edit_text(
        f"Вы выбрали подкнопку: {subbutton_data}\nВведите новое значение Data для этой подкнопки:",
        reply_markup=keyboard.as_markup()
    )
    await state.set_state(EditButtonStates.EDIT_SUBMENU)
    await callback.answer()

@edit_button_router.message(EditButtonStates.EDIT_SUBMENU)
async def process_edit_subbutton(message: Message, state: FSMContext):
    new_subbutton_data = message.text.strip()
    data = await state.get_data()
    button = data['original_button']
    old_subbutton_data = data['selected_subbutton']
    
    for i in range(1, 16):
        if getattr(button, f"submdata{i}", None) == old_subbutton_data:
            updates = {f"submdata{i}": new_subbutton_data}
            await update_button(state, updates)
            await state.update_data(pending_updates=updates)
            break
    
    await message.answer(f"Подкнопка изменена с {old_subbutton_data} на {new_subbutton_data}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.callback_query(F.data == "add_subbutton")
async def add_subbutton(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    button = data['original_button']
    
    free_slots = [i for i in range(1, 16) if not getattr(button, f"submdata{i}", None)]
    if not free_slots:
        await callback.message.edit_text("Максимальное количество подкнопок достигнуто.")
        await callback.answer()
        return
    
    await state.update_data(free_slots=free_slots)
    keyboard = InlineKeyboardBuilder()
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="edit_submenu"))
    
    await callback.message.edit_text(
        "Введите Data новой подкнопки:",
        reply_markup=keyboard.as_markup()
    )
    await state.set_state(EditButtonStates.ADD_SUBBUTTON)
    await callback.answer()

@edit_button_router.message(EditButtonStates.ADD_SUBBUTTON)
async def process_add_subbutton(message: Message, state: FSMContext):
    new_subbutton_data = message.text.strip()
    data = await state.get_data()
    free_slots = data['free_slots']
    
    slot = free_slots[0]
    updates = {f"submdata{slot}": new_subbutton_data}
    await update_button(state, updates)
    await state.update_data(pending_updates=updates)
    
    await message.answer(f"Подкнопка {new_subbutton_data} добавлена в позицию {slot}.")
    await confirm_changes(message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)

@edit_button_router.callback_query(F.data == "delete_subbutton")
async def delete_subbutton(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    button = data['original_button']
    
    submenus = [getattr(button, f"submdata{i}") for i in range(1, 16) if getattr(button, f"submdata{i}", None)]
    if not submenus:
        await callback.message.edit_text("Подменю пусто.")
        await callback.answer()
        return
    
    text = "Выберите подкнопку для удаления:\n"
    keyboard = InlineKeyboardBuilder()
    for i, sub in enumerate(submenus, start=1):
        keyboard.row(InlineKeyboardButton(text=f"{i}. {sub}", callback_data=f"confirm_delete:{sub}"))
    keyboard.row(InlineKeyboardButton(text="Назад", callback_data="edit_submenu"))
    
    await callback.message.edit_text(text, reply_markup=keyboard.as_markup())
    await callback.answer()

@edit_button_router.callback_query(F.data.startswith("confirm_delete:"))
async def confirm_delete_subbutton(callback: CallbackQuery, state: FSMContext):
    subbutton_data = callback.data.split(":")[1]
    data = await state.get_data()
    button = data['original_button']
    
    for i in range(1, 16):
        if getattr(button, f"submdata{i}", None) == subbutton_data:
            updates = {f"submdata{i}": None}
            await update_button(state, updates)
            await state.update_data(pending_updates=updates)
            break
    
    await callback.message.edit_text(f"Подкнопка {subbutton_data} удалена.")
    await confirm_changes(callback.message, state)
    await state.set_state(EditButtonStates.SELECT_PARAMETER)
    await callback.answer()

async def update_button(state: FSMContext, updates: dict):
    data = await state.get_data()
    button_data = data['button_data']
    
    try:
        async with async_session() as session:
            query = (
                buttons_table.update().
                where(buttons_table.c.data == button_data).
                values(**updates)
            )
            await session.execute(query)
            await session.commit()
    except Exception as e:
        raise ValueError(f"Ошибка при обновлении записи: {e}")

async def get_button_by_data(data: str):
    async with async_session() as session:
        query = select(buttons_table).where(buttons_table.c.data == data)
        result = await session.execute(query)
        return result.fetchone()

==================================================
Файл: bot\filters.py
==================================================

from aiogram.types import CallbackQuery

class IsAdminPanelCallback:
    def __init__(self, admin_data: list[str]):
        self.admin_data = admin_data

    async def __call__(self, callback: CallbackQuery) -> bool:
        return callback.data in self.admin_data

==================================================
Файл: bot\handlers.py
==================================================

# bot/handlers.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, FSInputFile
from utils.database import buttons_table, async_session
from sqlalchemy.future import select
from aiogram.utils.keyboard import InlineKeyboardBuilder
import os
import logging

router = Router()

# Асинхронная функция для получения записи из БД по Data
async def get_button_by_data(data: str):
    async with async_session() as session:
        query = select(buttons_table).where(buttons_table.c.data == data)
        result = await session.execute(query)
        return result.fetchone()

# Проверка существования кнопки
async def check_button_exists(data: str) -> bool:
    button = await get_button_by_data(data)
    return button is not None

# Обработчик для возврата в главное меню
@router.callback_query(F.data == "back_to_start")
async def handle_back_to_start(callback: CallbackQuery):
    # Удаляем текущее сообщение и отправляем в начало (будет обработано в basic_handlers)
    await callback.message.delete()
    await callback.bot.send_message(callback.from_user.id, "/start")
    await callback.answer()

# Обработчик для возврата к родительскому меню
@router.callback_query(F.data.startswith("back_to:"))
async def handle_back_button(callback: CallbackQuery):
    parent_data = callback.data.split(":")[1]
    
    parent_button = await get_button_by_data(parent_data)
    if not parent_button:
        await callback.answer("Родительская кнопка не найдена", show_alert=True)
        return

    if parent_button.type == "menu":
        keyboard = InlineKeyboardBuilder()
        for i in range(1, 16):
            submdata = getattr(parent_button, f"submdata{i}", None)
            if submdata and submdata != "0":
                sub_button = await get_button_by_data(submdata)
                if sub_button:
                    keyboard.row(
                        InlineKeyboardButton(text=sub_button.name, callback_data=submdata)
                    )
        
        if parent_button.parentdataorcommand != "start":
            keyboard.row(
                InlineKeyboardButton(
                    text="Назад",
                    callback_data=f"back_to:{parent_button.parentdataorcommand}"
                )
            )
        keyboard.row(
            InlineKeyboardButton(text="В главное меню", callback_data="back_to_start")
        )

        reply_markup = keyboard.as_markup()
        text = parent_button.text or "Меню"

        try:
            await callback.message.edit_text(text, reply_markup=reply_markup)
        except Exception as e:
            logging.error(f"Ошибка при редактировании сообщения: {e}")
            await callback.message.answer(text, reply_markup=reply_markup)
            await callback.message.delete()

        await callback.answer()

    elif parent_button.type == "text":
        reply_markup = InlineKeyboardBuilder().row(
            InlineKeyboardButton(
                text="Назад",
                callback_data=f"back_to:{parent_button.parentdataorcommand}"
            )
        ).as_markup()

        await callback.message.answer(
            text=parent_button.text,
            reply_markup=reply_markup
        )
        await callback.message.delete()
        await callback.answer()

    elif parent_button.type == "textimage":
        photo_path = f"img/{parent_button.data}.jpg"
        if not os.path.exists(photo_path):
            await callback.answer("Изображение не найдено", show_alert=True)
            return

        reply_markup = InlineKeyboardBuilder().row(
            InlineKeyboardButton(
                text="Назад",
                callback_data=f"back_to:{parent_button.parentdataorcommand}"
            )
        ).as_markup()

        await callback.message.answer_photo(
            photo=FSInputFile(photo_path),
            caption=parent_button.text,
            reply_markup=reply_markup
        )
        await callback.message.delete()
        await callback.answer()

    elif parent_button.type == "url":
        reply_markup = InlineKeyboardBuilder().row(
            InlineKeyboardButton(text=parent_button.name, url=parent_button.text),
            InlineKeyboardButton(
                text="Назад",
                callback_data=f"back_to:{parent_button.parentdataorcommand}"
            )
        ).as_markup()

        await callback.message.answer(
            text="Перейдите по ссылке:",
            reply_markup=reply_markup
        )
        await callback.message.delete()
        await callback.answer()

# Обработчик команд и callback-запросов для динамического меню
@router.message(F.text.startswith('/'))
@router.callback_query()
async def handle_button(event):
    if isinstance(event, Message):
        button_data = event.text[1:]  # Убираем слэш для команд
    elif isinstance(event, CallbackQuery):
        button_data = event.data
        if button_data.startswith("back_to:") or button_data == "back_to_start":
            return  # Пропускаем, если это возврат
    else:
        return

    if not await check_button_exists(button_data):
        if isinstance(event, CallbackQuery):
            await event.answer("Кнопка не найдена", show_alert=True)
        return

    button = await get_button_by_data(button_data)
    command, type_ = button.command, button.type

    if command == 1:  # Вызывается по команде
        if type_ == "menu":
            await cmd_menu_handler(event, button)
        elif type_ == "text":
            await cmd_text_handler(event, button)
        elif type_ == "textimage":
            await cmd_textimage_handler(event, button)
    elif command == 0:  # Вызывается по нажатию другой кнопки
        if type_ == "menu":
            await data_menu_handler(event, button)
        elif type_ == "text":
            await data_text_handler(event, button)
        elif type_ == "textimage":
            await data_textimage_handler(event, button)
        elif type_ == "url":
            await data_url_handler(event, button)

# Обработчики для команд
async def cmd_menu_handler(event, button):
    keyboard = InlineKeyboardBuilder()
    for i in range(1, 16):
        submdata = getattr(button, f"submdata{i}", None)
        if submdata and submdata != "0":
            sub_button = await get_button_by_data(submdata)
            if sub_button:
                if sub_button.type == "url":
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, url=sub_button.text))
                else:
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, callback_data=submdata))
    
    keyboard.row(InlineKeyboardButton(text="В главное меню", callback_data="back_to_start"))
    reply_markup = keyboard.as_markup()
    text = button.text or "Меню"

    if isinstance(event, Message):
        await event.answer(text, reply_markup=reply_markup)
    elif isinstance(event, CallbackQuery):
        await event.message.edit_text(text, reply_markup=reply_markup)
        await event.answer()

async def cmd_text_handler(event, button):
    reply_markup = InlineKeyboardBuilder().row(
        InlineKeyboardButton(text="В главное меню", callback_data="back_to_start")
    ).as_markup()

    if isinstance(event, Message):
        await event.answer(button.text, reply_markup=reply_markup)
    elif isinstance(event, CallbackQuery):
        try:
            await event.message.edit_text(button.text, reply_markup=reply_markup)
        except Exception as e:
            logging.error(f"Ошибка при редактировании сообщения: {e}")
            await event.message.answer(button.text, reply_markup=reply_markup)
            await event.message.delete()
        await event.answer()

async def cmd_textimage_handler(event, button):
    photo_path = f"img/{button.data}.jpg"
    if not os.path.exists(photo_path):
        await event.answer("Изображение не найдено", show_alert=True)
        return

    reply_markup = InlineKeyboardBuilder().row(
        InlineKeyboardButton(text="В главное меню", callback_data="back_to_start")
    ).as_markup()

    if isinstance(event, Message):
        await event.answer_photo(
            photo=FSInputFile(photo_path),
            caption=button.text,
            reply_markup=reply_markup
        )
    elif isinstance(event, CallbackQuery):
        await event.message.answer_photo(
            photo=FSInputFile(photo_path),
            caption=button.text,
            reply_markup=reply_markup
        )
        await event.message.delete()
        await event.answer()

# Обработчики для кнопок
async def data_menu_handler(event, button):
    keyboard = InlineKeyboardBuilder()
    for i in range(1, 16):
        submdata = getattr(button, f"submdata{i}", None)
        if submdata and submdata != "0":
            sub_button = await get_button_by_data(submdata)
            if sub_button:
                if sub_button.type == "url":
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, url=sub_button.text))
                else:
                    keyboard.row(InlineKeyboardButton(text=sub_button.name, callback_data=submdata))

    keyboard.row(InlineKeyboardButton(text="Назад", callback_data=f"back_to:{button.parentdataorcommand}"))
    reply_markup = keyboard.as_markup()
    text = button.text or "Меню"

    if isinstance(event, CallbackQuery):
        await event.message.edit_text(text, reply_markup=reply_markup)
        await event.answer()

async def data_text_handler(event, button):
    reply_markup = InlineKeyboardBuilder().row(
        InlineKeyboardButton(text="Назад", callback_data=f"back_to:{button.parentdataorcommand}")
    ).as_markup()

    if isinstance(event, CallbackQuery):
        await event.message.edit_text(button.text, reply_markup=reply_markup)
        await event.answer()

async def data_textimage_handler(event: CallbackQuery, button):
    photo_path = f"img/{button.data}.jpg"
    if not os.path.exists(photo_path):
        await event.answer("Изображение не найдено", show_alert=True)
        return

    reply_markup = InlineKeyboardBuilder().row(
        InlineKeyboardButton(text="Назад", callback_data=f"back_to:{button.parentdataorcommand}")
    ).as_markup()

    await event.message.answer_photo(
        photo=FSInputFile(photo_path),
        caption=button.text,
        reply_markup=reply_markup
    )
    await event.message.delete()
    await event.answer()

async def data_url_handler(event, button):
    reply_markup = InlineKeyboardBuilder().row(
        InlineKeyboardButton(text=button.name, url=button.text),
        InlineKeyboardButton(text="Назад", callback_data=f"back_to:{button.parentdataorcommand}")
    ).as_markup()

    if isinstance(event, CallbackQuery):
        await event.message.edit_text("Перейдите по ссылке:", reply_markup=reply_markup)
        await event.answer()

==================================================
Файл: bot\view_buttons.py
==================================================

# bot/view_buttons.py

from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from utils.database import buttons_table, async_session
from sqlalchemy.future import select
from aiogram.utils.keyboard import InlineKeyboardBuilder

view_buttons_router = Router()

ITEMS_PER_PAGE = 3  # Максимум 3 кнопки на страницу
MAX_MESSAGE_LENGTH = 4096  # Лимит Telegram

# Определяем состояния для ввода номера страницы и поиска
class ViewStates(StatesGroup):
    WAITING_FOR_PAGE = State()
    WAITING_FOR_SEARCH_VALUE = State()

# Функция для получения кнопок с пагинацией
async def get_paginated_buttons(page: int, limit: int = ITEMS_PER_PAGE):
    offset = page * ITEMS_PER_PAGE
    async with async_session() as session:
        query = select(buttons_table).offset(offset).limit(limit)
        result = await session.execute(query)
        return result.fetchall()

# Функция для получения общего количества кнопок
async def get_total_buttons():
    async with async_session() as session:
        query = select(buttons_table)
        result = await session.execute(query)
        return len(result.fetchall())

# Функция для поиска кнопок по критерию
async def search_buttons(criterion: str, value: str):
    async with async_session() as session:
        if criterion == "data":
            query = select(buttons_table).where(buttons_table.c.data.ilike(f"%{value}%"))
        elif criterion == "command":
            query = select(buttons_table).where(buttons_table.c.command == (1 if value.lower() in ["команда", "1"] else 0))
        elif criterion == "name":
            query = select(buttons_table).where(buttons_table.c.name.ilike(f"%{value}%"))
        else:
            return []
        result = await session.execute(query)
        return result.fetchall()

# Функция для формирования текста кнопок с динамическим количеством
def format_buttons(buttons, max_length=MAX_MESSAGE_LENGTH):
    text = ""
    valid_buttons = []
    for button in buttons:
        name = button.name if button.name and button.name != "0" else "Нет названия"
        command_text = f"Вызывается по команде - /{button.parentdataorcommand}" if button.command == 1 else f"Вызывается по нажатию кнопки в меню - {button.parentdataorcommand}"
        button_type = button.type
        button_text = button.text or "Отсутствует"
        if len(button_text) > 100:
            button_text = button_text[:100] + "... (обрезано)"
        
        submenus = [getattr(button, f"submdata{i}") for i in range(1, 16) if getattr(button, f"submdata{i}")]
        submenu_text = ", ".join(submenus) if submenus else "Отсутствуют"

        button_text_entry = (
            f"🏷 *Название*: {name} | *Data*: {button.data}\n"
            f"🔧 *Тип*: {button_type}\n"
            f"📞 *Вызов*: {command_text}\n"
            f"📝 *Текст*: {button_text}\n"
            f"🌐 *Подменю*: {submenu_text}\n"
            "────────────────────\n"
        )
        
        if len(text) + len(button_text_entry) <= max_length - 50:  # 50 - запас на заголовок
            text += button_text_entry
            valid_buttons.append(button)
        else:
            break
    
    return text.strip(), len(valid_buttons), valid_buttons

# Обработчик для просмотра кнопок с пагинацией
@view_buttons_router.callback_query(F.data.startswith("view_buttons"))
async def show_buttons(callback: CallbackQuery, state: FSMContext = None):
    await callback.message.delete()
    page = int(callback.data.split(":")[1]) if ":" in callback.data else 0
    
    buttons = await get_paginated_buttons(page)
    total_buttons = await get_total_buttons()
    total_pages = (total_buttons + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

    if not buttons:
        await callback.message.answer("Список кнопок пуст.")
        return

    text, items_displayed, _ = format_buttons(buttons)
    text = f"**Страница {page + 1} из {total_pages}**\n\n" + text

    if len(text) > MAX_MESSAGE_LENGTH:
        await callback.message.answer("Слишком много данных для отображения.")
        return

    keyboard = InlineKeyboardBuilder()
    if page > 0:
        keyboard.button(text="⬅ Предыдущая", callback_data=f"view_buttons:{page - 1}")
        if page < total_pages - 1:
            keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page + 1}")
    elif page < total_pages - 1:
        keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page + 1}")
    
    if page > 0 or page < total_pages - 1:
        if page > 0:
            keyboard.button(text="⏮ Первая", callback_data="view_buttons:0")
        if page < total_pages - 1:
            keyboard.button(text="Последняя ⏭", callback_data=f"view_buttons:{total_pages - 1}")
    
    keyboard.button(text="Ввести номер страницы", callback_data="input_page")
    keyboard.button(text="Искать кнопку по", callback_data="search_button")
    keyboard.button(text="Назад", callback_data="back_to_dynamic_menu")
    keyboard.adjust(2, 2, 1, 1, 1)

    await callback.message.answer(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
    await callback.answer()

# Обработчик для навигации по всем кнопкам
@view_buttons_router.callback_query(F.data.startswith("view_buttons:"))
async def navigate_buttons(callback: CallbackQuery, state: FSMContext = None):
    page = int(callback.data.split(":")[1])
    
    buttons = await get_paginated_buttons(page)
    total_buttons = await get_total_buttons()
    total_pages = (total_buttons + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

    if not buttons:
        await callback.message.edit_text("Список кнопок пуст.")
        return

    text, items_displayed, _ = format_buttons(buttons)
    text = f"**Страница {page + 1} из {total_pages}**\n\n" + text

    if len(text) > MAX_MESSAGE_LENGTH:
        await callback.message.edit_text("Слишком много данных для отображения.")
        return

    keyboard = InlineKeyboardBuilder()
    if page > 0:
        keyboard.button(text="⬅ Предыдущая", callback_data=f"view_buttons:{page - 1}")
        if page < total_pages - 1:
            keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page + 1}")
    elif page < total_pages - 1:
        keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page + 1}")
    
    if page > 0 or page < total_pages - 1:
        if page > 0:
            keyboard.button(text="⏮ Первая", callback_data="view_buttons:0")
        if page < total_pages - 1:
            keyboard.button(text="Последняя ⏭", callback_data=f"view_buttons:{total_pages - 1}")
    
    keyboard.button(text="Ввести номер страницы", callback_data="input_page")
    keyboard.button(text="Искать кнопку по", callback_data="search_button")
    keyboard.button(text="Назад", callback_data="back_to_dynamic_menu")
    keyboard.adjust(2, 2, 1, 1, 1)

    await callback.message.edit_text(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
    await callback.answer()

# Обработчик для ввода номера страницы
@view_buttons_router.callback_query(F.data == "input_page")
async def start_input_page(callback: CallbackQuery, state: FSMContext):
    total_buttons = await get_total_buttons()
    total_pages = (total_buttons + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    await callback.message.delete()  # Удаляем предыдущее меню просмотра кнопок
    await callback.message.answer(
        f"🔢 *Введите номер страницы (от 1 до {total_pages}):*",
        reply_markup=InlineKeyboardBuilder()
        .button(text="⬅ Назад", callback_data="view_buttons:0")
        .as_markup(),
        parse_mode="Markdown"
    )
    await state.set_state(ViewStates.WAITING_FOR_PAGE)
    await callback.answer()

# Обработчик ввода номера страницы
@view_buttons_router.message(ViewStates.WAITING_FOR_PAGE)
async def process_page_input(message: Message, state: FSMContext):
    try:
        page_num = int(message.text.strip()) - 1
        total_buttons = await get_total_buttons()
        total_pages = (total_buttons + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

        if 0 <= page_num < total_pages:
            buttons = await get_paginated_buttons(page_num)
            text, items_displayed, _ = format_buttons(buttons)
            text = f"**Страница {page_num + 1} из {total_pages}**\n\n" + text

            keyboard = InlineKeyboardBuilder()
            if page_num > 0:
                keyboard.button(text="⬅ Предыдущая", callback_data=f"view_buttons:{page_num - 1}")
                if page_num < total_pages - 1:
                    keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page_num + 1}")
            elif page_num < total_pages - 1:
                keyboard.button(text="Следующая ➡", callback_data=f"view_buttons:{page_num + 1}")
            
            if page_num > 0 or page_num < total_pages - 1:
                if page_num > 0:
                    keyboard.button(text="⏮ Первая", callback_data="view_buttons:0")
                if page_num < total_pages - 1:
                    keyboard.button(text="Последняя ⏭", callback_data=f"view_buttons:{total_pages - 1}")
            
            keyboard.button(text="Ввести номер страницы", callback_data="input_page")
            keyboard.button(text="Искать кнопку по", callback_data="search_button")
            keyboard.button(text="Назад", callback_data="back_to_dynamic_menu")
            keyboard.adjust(2, 2, 1, 1, 1)

            await message.answer(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
        else:
            await message.answer(f"⚠️ Пожалуйста, введите номер от 1 до {total_pages}.")
    except ValueError:
        await message.answer("⚠️ Пожалуйста, введите корректный номер страницы (число).")
    finally:
        await state.clear()

# Обработчик кнопки "Искать кнопку по"
@view_buttons_router.callback_query(F.data == "search_button")
async def show_search_menu(callback: CallbackQuery):
    keyboard = InlineKeyboardBuilder()
    keyboard.button(text="По Data", callback_data="search_by:data")
    keyboard.button(text="По типу вызова", callback_data="search_by:command")
    keyboard.button(text="По названию", callback_data="search_by:name")
    keyboard.button(text="⬅ Назад", callback_data="back_to_view")
    keyboard.adjust(1)

    await callback.message.edit_text(
        "🔍 *Выберите, по чему искать кнопку:*",
        reply_markup=keyboard.as_markup(),
        parse_mode="Markdown"
    )
    await callback.answer()

# Обработчик выбора критерия поиска
@view_buttons_router.callback_query(F.data.startswith("search_by:"))
async def start_search_by(callback: CallbackQuery, state: FSMContext):
    criterion = callback.data.split(":")[1]
    await state.update_data(search_criterion=criterion)
    
    if criterion == "command":
        await callback.message.edit_text(
            "🔍 *Введите тип вызова* (например, 'команда' или 'кнопка'):",
            reply_markup=InlineKeyboardBuilder()
            .button(text="❌ Отмена поиска", callback_data="cancel_search")
            .as_markup(),
            parse_mode="Markdown"
        )
    else:
        await callback.message.edit_text(
            f"🔍 *Введите значение для поиска по {criterion}:*",
            reply_markup=InlineKeyboardBuilder()
            .button(text="❌ Отмена поиска", callback_data="cancel_search")
            .as_markup(),
            parse_mode="Markdown"
        )
    
    await state.set_state(ViewStates.WAITING_FOR_SEARCH_VALUE)
    await callback.answer()

# Обработчик ввода значения для поиска
@view_buttons_router.message(ViewStates.WAITING_FOR_SEARCH_VALUE)
async def process_search_input(message: Message, state: FSMContext):
    value = message.text.strip()
    data = await state.get_data()
    criterion = data.get("search_criterion")

    buttons = await search_buttons(criterion, value)
    await message.delete()  # Удаляем сообщение с запросом ввода

    if not buttons:
        keyboard = InlineKeyboardBuilder()
        keyboard.button(text="🔍 Искать ещё раз", callback_data="search_button")
        keyboard.button(text="❌ Отмена поиска", callback_data="cancel_search")
        keyboard.adjust(1)
        await message.answer(
            f"⚠️ *Ничего не найдено по {criterion}: '{value}'*",
            reply_markup=keyboard.as_markup(),
            parse_mode="Markdown"
        )
        await state.clear()
        return

    total_search_results = len(buttons)
    total_search_pages = (total_search_results + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    
    if total_search_results <= ITEMS_PER_PAGE:
        text, items_displayed, _ = format_buttons(buttons)
        text = f"**🔍 Результаты поиска по {criterion}: '{value}'**\n\n" + text

        keyboard = InlineKeyboardBuilder()
        keyboard.button(text="⬅ Назад", callback_data="cancel_search")
        keyboard.adjust(1)

        await message.answer(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
    else:
        # Если слишком много результатов, переходим в меню поиска с пагинацией
        await state.update_data(search_results=buttons, search_criterion=criterion, search_value=value)
        await show_search_results(callback=message, state=state, page=0)

    await state.clear()

# Обработчик для просмотра результатов поиска с пагинацией
async def show_search_results(callback: Message | CallbackQuery, state: FSMContext, page: int):
    data = await state.get_data()
    buttons = data.get("search_results", [])
    criterion = data.get("search_criterion")
    value = data.get("search_value")
    total_search_results = len(buttons)
    total_search_pages = (total_search_results + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

    start_idx = page * ITEMS_PER_PAGE
    end_idx = min(start_idx + ITEMS_PER_PAGE, total_search_results)
    page_buttons = buttons[start_idx:end_idx]

    text, items_displayed, _ = format_buttons(page_buttons)
    text = f"**🔍 Результаты поиска по {criterion}: '{value}' (Страница {page + 1} из {total_search_pages})**\n\n" + text

    keyboard = InlineKeyboardBuilder()
    if page > 0:
        keyboard.button(text="⬅ Предыдущая", callback_data=f"search_page:{page - 1}")
        if page < total_search_pages - 1:
            keyboard.button(text="Следующая ➡", callback_data=f"search_page:{page + 1}")
    elif page < total_search_pages - 1:
        keyboard.button(text="Следующая ➡", callback_data=f"search_page:{page + 1}")
    
    if page > 0 or page < total_search_pages - 1:
        if page > 0:
            keyboard.button(text="⏮ Первая", callback_data="search_page:0")
        if page < total_search_pages - 1:
            keyboard.button(text="Последняя ⏭", callback_data=f"search_page:{total_search_pages - 1}")
    
    keyboard.button(text="⬅ Назад ко всем кнопкам", callback_data="cancel_search")
    keyboard.adjust(2, 2, 1)

    if isinstance(callback, Message):
        await callback.answer(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
    else:
        await callback.message.edit_text(text, reply_markup=keyboard.as_markup(), parse_mode="Markdown")
        await callback.answer()

# Обработчик навигации по страницам результатов поиска
@view_buttons_router.callback_query(F.data.startswith("search_page:"))
async def navigate_search_results(callback: CallbackQuery, state: FSMContext):
    page = int(callback.data.split(":")[1])
    await show_search_results(callback, state, page)

# Обработчик возврата к просмотру кнопок
@view_buttons_router.callback_query(F.data == "back_to_view")
async def back_to_view(callback: CallbackQuery):
    await show_buttons(callback)  # Возвращаемся к первой странице

# Обработчик отмены поиска
@view_buttons_router.callback_query(F.data == "cancel_search")
async def cancel_search(callback: CallbackQuery):
    await show_buttons(callback)  # Возвращаемся к первой странице

# Обработчик кнопки "Назад"
@view_buttons_router.callback_query(F.data == "back_to_dynamic_menu")
async def back_to_dynamic_menu(callback: CallbackQuery):
    from bot.adminpanel import DYNAMIC_MENU
    await callback.message.edit_text(
        "Вы можете управлять динамическим меню:",
        reply_markup=DYNAMIC_MENU
    )
    await callback.answer()

==================================================
Файл: bot\__init__.py
==================================================



==================================================
Файл: templates\dashboard.html
==================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Главная</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-light">
    <div class="container mt-4">
        <!-- Навигационная панель -->
        <nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm mb-4">
            <div class="container-fluid">
                <h1 class="navbar-brand mb-0">Главная</h1>
                <div class="navbar-nav ms-auto">
                    <a href="{{ url_for('dashboard.index') }}" class="nav-link" title="Обновить">
                        <i class="fas fa-sync-alt"></i>
                    </a>
                    <a href="{{ url_for('logout') }}" class="nav-link" title="Выйти">
                        <i class="fas fa-sign-out-alt"></i>
                    </a>
                </div>
            </div>
        </nav>

        <!-- Основной контент -->
        <div class="row">
            <div class="col-md-12">
                <!-- Панель кнопок -->
                <div class="card shadow-sm">
                    <div class="card-body text-center">
                        <h2 class="card-title mb-4">Панель управления</h2>
                        <div class="row g-3">
                            <div class="col-md-3">
                                <a href="{{ url_for('tasks.index') }}" class="btn btn-primary w-100">
                                    <i class="fas fa-tasks me-2"></i>Задачи
                                </a>
                            </div>
                            <div class="col-md-3"> <!-- Добавьте этот блок -->
                                <a href="{{ url_for('roles.index') }}" class="btn btn-primary w-100">
                                    <i class="fas fa-users me-2"></i>Роли и пользователи
                                </a>
                            </div>
                            <!-- Нереализованные разделы временно убраны -->
                        </div>
                    </div>
                </div>

                <!-- Статистика -->
                <div class="card shadow-sm mt-4">
                    <div class="card-body">
                        <h3 class="card-title">Статистика</h3>
                        <p class="text-muted">Общее количество задач: {{ total_tasks or 'N/A' }}</p>
                        <p class="text-muted">Активных пользователей: {{ active_users or 'N/A' }}</p>
                        <p class="text-muted">Подробная статистика будет добавлена позже.</p>
                    </div>
                </div>

                <!-- Инструкция -->
                <div class="card shadow-sm mt-4">
                    <div class="card-body">
                        <h3 class="card-title">Инструкция</h3>
                        <p>Добро пожаловать в панель управления! Используйте кнопки выше для навигации:</p>
                        <ul>
                            <li><strong>Задачи:</strong> Управление задачами сотрудников.</li>
                            <!-- Описания нереализованных разделов временно убраны -->
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

==================================================
Файл: templates\login.html
==================================================

<!-- templates/login.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вход для руководителя</title>
    <!-- Bootstrap 5.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
</head>
<body class="bg-light">
    <div class="container">
        <div class="row justify-content-center align-items-center min-vh-100">
            <div class="col-md-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h1 class="card-title text-center mb-4">Вход для руководителя</h1>
                        <!-- Форма авторизации -->
                        <form method="POST" action="{{ url_for('login') }}">
                            <div class="mb-3">
                                <label for="login" class="form-label">Логин</label>
                                <input type="text" class="form-control" id="login" name="login" required>
                            </div>
                            <div class="mb-3">
                                <label for="password" class="form-label">Пароль</label>
                                <input type="password" class="form-control" id="password" name="password" required>
                            </div>
                            <button type="submit" class="btn btn-primary w-100">Войти</button>
                        </form>
                        <!-- Сообщение об ошибке -->
                        {% with messages = get_flashed_messages(with_categories=true) %}
                            {% if messages %}
                                {% for category, message in messages %}
                                    <div class="alert alert-{{ category }} mt-3" role="alert">
                                        {{ message }}
                                    </div>
                                {% endfor %}
                            {% endif %}
                        {% endwith %}
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Bootstrap 5.3 JS (для будущих модальных окон и динамики) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
</body>
</html>

==================================================
Файл: templates\roles.html
==================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Роли</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .table-editable {
            background-color: #f8f9fa;
            border: 2px solid #007bff;
        }
        .table-editable .editable:hover {
            background-color: #e9ecef;
            cursor: pointer;
        }
        .editable {
            transition: background-color 0.2s;
        }
    </style>
</head>
<body class="bg-light">
    <div class="container mt-4">
        <!-- Навигационная панель -->
        <nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm mb-4">
            <div class="container-fluid">
                <h1 class="navbar-brand mb-0">Роли</h1>
                <div class="navbar-nav ms-auto">
                    <a href="{{ url_for('roles.index') }}" class="nav-link" title="Обновить"><i class="fas fa-sync-alt"></i></a>
                    <a href="{{ url_for('dashboard.index') }}" class="nav-link" title="На главную"><i class="fas fa-home"></i></a>
                    <a href="{{ url_for('logout') }}" class="nav-link" title="Выйти"><i class="fas fa-sign-out-alt"></i></a>
                </div>
            </div>
        </nav>

        <div class="card shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">Список ролей</h5>
                <div>
                    <button class="btn btn-primary me-2" id="toggle-edit-mode">Включить редактирование</button>
                    <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#addRoleModal"><i class="fas fa-plus"></i> Добавить роль</button>
                </div>
            </div>
            <div class="card-body">
                <form method="get" action="{{ url_for('roles.index') }}" class="mb-3">
                    <div class="row g-3">
                        <div class="col-md-3">
                            <label for="group" class="form-label fw-bold">Группа</label>
                            <select name="group" id="group" class="form-select" onchange="this.form.submit()">
                                <option value="all" {% if group_filter == 'all' %}selected{% endif %}>Все группы</option>
                                {% for group in groups %}
                                    <option value="{{ group }}" {% if group_filter == group %}selected{% endif %}>{{ group }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="search" class="form-label fw-bold">Поиск по названию</label>
                            <input type="text" name="search" id="search" class="form-control" value="{{ search_query }}" placeholder="Введите название роли">
                        </div>
                        <div class="col-md-3">
                            <div class="form-check mt-4">
                                <input type="checkbox" class="form-check-input" id="only_with_users" name="only_with_users" {% if only_with_users %}checked{% endif %} onchange="this.form.submit()">
                                <label class="form-check-label" for="only_with_users">Только с пользователями</label>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <button type="submit" class="btn btn-primary mt-4"><i class="fas fa-filter"></i> Применить</button>
                        </div>
                    </div>
                </form>

                <table class="table table-hover">
                    <thead>
                        <tr>
                            <th>№</th>
                            <th>ID роли</th>
                            <th>Полная роль</th>
                            <th>Группа</th>
                            <th>Подгруппа</th>
                            <th>Пароль</th>
                            <th>Пользователи</th>
                            <th>Действия</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for role in roles %}
                        <tr class="{% if not users_by_role[role.role_id] %}bg-warning{% endif %}" data-role-id="{{ role.role_id }}">
                            <td>{{ loop.index + (page - 1) * per_page }}</td>
                            <td class="editable" data-field="role_id">{{ role.role_id }}</td>
                            <td class="editable" data-field="role_full_name">{{ role.role_full_name }}</td>
                            <td class="editable" data-field="role_group">{{ role.role_group or '-' }}</td>
                            <td class="editable" data-field="role_subgroup">{{ role.role_subgroup or '-' }}</td>
                            <td class="editable" data-field="rolepass">{{ role.rolepass }}</td>
                            <td>
                                {% for user in users_by_role[role.role_id] %}
                                    <span class="badge bg-secondary">
                                        {{ user.user_name or user.user_id }} ({{ user.user_id }})
                                        <button class="btn btn-sm btn-danger delete-user" data-user-id="{{ user.user_id }}" data-bs-toggle="tooltip" title="Удалить пользователя из роли"><i class="fas fa-times"></i></button>
                                    </span>
                                {% endfor %}
                                <button class="btn btn-sm btn-primary add-user mt-1" data-bs-toggle="modal" data-bs-target="#addUserModal{{ role.role_id }}" data-bs-toggle="tooltip" title="Добавить пользователя"><i class="fas fa-plus"></i></button>
                            </td>
                            <td>
                                <button class="btn btn-sm btn-warning" data-bs-toggle="modal" data-bs-target="#editRoleModal" onclick="editRole('{{ role.role_id }}')" data-bs-toggle="tooltip" title="Редактировать роль через форму"><i class="fas fa-pencil-alt"></i></button>
                                <button class="btn btn-sm btn-danger delete-row-btn" style="display: none;" data-bs-toggle="tooltip" title="Удалить роль"><i class="fas fa-trash"></i></button>
                                <form action="{{ url_for('roles.regenerate_password', role_id=role.role_id) }}" method="post" style="display:inline;">
                                    <button type="submit" class="btn btn-sm btn-info" onclick="return confirm('Сгенерировать новый пароль и отвязать пользователей?')" data-bs-toggle="tooltip" title="Обновить пароль и отвязать всех пользователей"><i class="fas fa-sync-alt"></i></button>
                                </form>
                                <form action="{{ url_for('roles.send_password', role_id=role.role_id) }}" method="post" style="display:inline;">
                                    <button type="submit" class="btn btn-sm btn-primary" onclick="return confirm('Отправить пароль всем пользователям роли?')" data-bs-toggle="tooltip" title="Отправить текущий пароль пользователям"><i class="fas fa-envelope"></i></button>
                                </form>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>

                <button id="add-row-btn" class="btn btn-success mb-3" style="display: none;"><i class="fas fa-plus"></i> Добавить строку</button>

                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <select id="per_page" data-base-url="{{ url_for('roles.index', group=group_filter, search=search_query, only_with_users='on' if only_with_users else '') }}" class="form-select d-inline-block w-auto">
                            <option value="10" {% if per_page == 10 %}selected{% endif %}>10</option>
                            <option value="25" {% if per_page == 25 %}selected{% endif %}>25</option>
                            <option value="50" {% if per_page == 50 %}selected{% endif %}>50</option>
                            <option value="100" {% if per_page == 100 %}selected{% endif %}>100</option>
                        </select>
                        строк на странице
                    </div>
                    <nav>
                        <ul class="pagination">
                            <li class="page-item {% if page == 1 %}disabled{% endif %}">
                                <a class="page-link" href="{{ url_for('roles.index', page=page-1, per_page=per_page, group=group_filter, search=search_query, only_with_users='on' if only_with_users else '') }}">Предыдущая</a>
                            </li>
                            <li class="page-item">
                                <span class="page-link">Страница {{ page }} из {{ total_pages }}</span>
                            </li>
                            <li class="page-item {% if page == total_pages %}disabled{% endif %}">
                                <a class="page-link" href="{{ url_for('roles.index', page=page+1, per_page=per_page, group=group_filter, search=search_query, only_with_users='on' if only_with_users else '') }}">Следующая</a>
                            </li>
                            <li class="page-item">
                                <input type="number" id="page_input" min="1" max="{{ total_pages }}" class="form-control d-inline-block w-auto" style="width: 70px;" placeholder="{{ page }}">
                                <button class="btn btn-primary btn-sm" onclick="goToPage()">Перейти</button>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
            <div class="card-footer">
                <button id="save-changes" class="btn btn-primary me-2" style="display: none;">Сохранить изменения</button>
                <a href="{{ url_for('dashboard.index') }}" class="btn btn-secondary">Вернуться на главную</a>
            </div>
        </div>
    </div>

    <!-- Модальное окно добавления роли -->
    <div class="modal fade" id="addRoleModal" tabindex="-1" aria-labelledby="addRoleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addRoleModalLabel">Добавить роль</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form method="post" action="{{ url_for('roles.add_role') }}">
                        <div class="mb-3">
                            <label for="role_id" class="form-label">ID роли</label>
                            <input type="text" name="role_id" id="role_id" class="form-control" required pattern="[a-zA-Z0-9]+" title="Только буквы и цифры">
                        </div>
                        <div class="mb-3">
                            <label for="role_full_name" class="form-label">Полное название</label>
                            <input type="text" name="role_full_name" id="role_full_name" class="form-control" required>
                        </div>
                        <div class="mb-3">
                            <label for="role_group" class="form-label">Группа</label>
                            <input type="text" name="role_group" id="role_group" class="form-control">
                        </div>
                        <div class="mb-3">
                            <label for="role_subgroup" class="form-label">Подгруппа</label>
                            <input type="text" name="role_subgroup" id="role_subgroup" class="form-control">
                        </div>
                        <button type="submit" class="btn btn-primary">Сохранить</button>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно редактирования роли -->
    <div class="modal fade" id="editRoleModal" tabindex="-1" aria-labelledby="editRoleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editRoleModalLabel">Редактировать роль</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="edit-role-form" data-role-id="">
                        <div class="mb-3">
                            <label for="edit_role_id" class="form-label">ID роли</label>
                            <input type="text" name="role_id" id="edit_role_id" class="form-control" required pattern="[a-zA-Z0-9]+" title="Только буквы и цифры">
                        </div>
                        <div class="mb-3">
                            <label for="edit_role_full_name" class="form-label">Полное название</label>
                            <input type="text" name="role_full_name" id="edit_role_full_name" class="form-control" required>
                        </div>
                        <div class="mb-3">
                            <label for="edit_role_group" class="form-label">Группа</label>
                            <input type="text" name="role_group" id="edit_role_group" class="form-control">
                        </div>
                        <div class="mb-3">
                            <label for="edit_role_subgroup" class="form-label">Подгруппа</label>
                            <input type="text" name="role_subgroup" id="edit_role_subgroup" class="form-control">
                        </div>
                        <div class="mb-3">
                            <label for="edit_rolepass" class="form-label">Пароль</label>
                            <input type="text" name="rolepass" id="edit_rolepass" class="form-control">
                        </div>
                        <button type="button" class="btn btn-primary" onclick="saveEditedRole()">Сохранить</button>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальные окна добавления пользователя -->
    {% for role in roles %}
    <div class="modal fade" id="addUserModal{{ role.role_id }}" tabindex="-1" aria-labelledby="addUserModalLabel{{ role.role_id }}" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addUserModalLabel{{ role.role_id }}">Добавить пользователя к роли {{ role.role_full_name }}</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="user_id_{{ role.role_id }}" class="form-label">Telegram ID</label>
                        <input type="text" id="user_id_{{ role.role_id }}" class="form-control" pattern="[0-9]+" title="Только цифры" required>
                    </div>
                    <div class="mb-3">
                        <label for="user_name_{{ role.role_id }}" class="form-label">Имя пользователя (необязательно)</label>
                        <input type="text" id="user_name_{{ role.role_id }}" class="form-control">
                    </div>
                    <button type="button" class="btn btn-primary" onclick="addUser('{{ role.role_id }}')">Добавить</button>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                </div>
            </div>
        </div>
    </div>
    {% endfor %}

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/roles.js') }}"></script>
</body>
</html>

==================================================
Файл: templates\tasks.html
==================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Задачи</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-light">
    <div class="container mt-4">
        <!-- Навигационная панель -->
        <nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm mb-4">
            <div class="container-fluid">
                <h1 class="navbar-brand mb-0">Задачи</h1>
                <div class="navbar-nav ms-auto">
                    <a href="{{ url_for('tasks.index') }}" class="nav-link" title="Обновить">
                        <i class="fas fa-sync-alt"></i>
                    </a>
                    <a href="{{ url_for('dashboard.index') }}" class="nav-link" title="На главную">
                        <i class="fas fa-home"></i>
                    </a>
                    <a href="{{ url_for('logout') }}" class="nav-link" title="Выйти">
                        <i class="fas fa-sign-out-alt"></i>
                    </a>
                </div>
            </div>
        </nav>
        <div class="card shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">Задачи</h5>
                <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#addTaskModal"><i class="fas fa-plus"></i> Добавить задачу</button>
            </div>
            <div class="card-body">
                <!-- Фильтры -->
                <form method="get" action="{{ url_for('tasks.index') }}" class="mb-3">
                    <div class="row g-3">
                        <div class="col-md-2">
                            <label for="status" class="form-label fw-bold">Фильтр по состоянию</label>
                            <select name="status" id="status" class="form-select" onchange="this.form.submit()">
                                <option value="all" {% if status_filter == 'all' %}selected{% endif %}>Все состояния</option>
                                <option value="sent" {% if status_filter == 'sent' %}selected{% endif %}>Отправлено</option>
                                <option value="accepted" {% if status_filter == 'accepted' %}selected{% endif %}>Принято</option>
                                <option value="completed" {% if status_filter == 'completed' %}selected{% endif %}>Выполнено</option>
                                <option value="overdue" {% if status_filter == 'overdue' %}selected{% endif %}>Просрочено</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label for="deadline" class="form-label fw-bold">Фильтр по дедлайну</label>
                            <select name="deadline" id="deadline" class="form-select" onchange="this.form.submit()">
                                <option value="all" {% if deadline_filter == 'all' %}selected{% endif %}>Все дедлайны</option>
                                <option value="overdue" {% if deadline_filter == 'overdue' %}selected{% endif %}>Просрочены</option>
                                <option value="today" {% if deadline_filter == 'today' %}selected{% endif %}>Сегодня</option>
                                <option value="future" {% if deadline_filter == 'future' %}selected{% endif %}>В будущем</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label for="executor_group" class="form-label fw-bold">Фильтр по исполнителю</label>
                            <select name="executor" id="executor_group" class="form-select" onchange="this.form.submit()">
                                <option value="all" {% if executor_filter == 'all' %}selected{% endif %}>Все исполнители</option>
                                <option value="all_employees" {% if executor_filter == 'all_employees' %}selected{% endif %}>Все сотрудники</option>
                                {% for group in groups %}
                                    <option value="{{ group }}" {% if executor_filter == group %}selected{% endif %}>Все {{ group }}</option>
                                {% endfor %}
                                {% for role in roles %}
                                    {% if role.role_subgroup %}
                                        <option value="{{ role.role_id }}" {% if executor_filter == role.role_id %}selected{% endif %}>{{ role.role_full_name }}</option>
                                    {% endif %}
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label for="frequency" class="form-label fw-bold">Частота задач</label>
                            <select name="frequency" id="frequency" class="form-select" onchange="this.form.submit()">
                                <option value="all" {% if frequency_filter == 'all' %}selected{% endif %}>Все частоты</option>
                                {% for freq in frequencies %}
                                    {% set freq_display = "Раз в " ~ freq.split()[0] ~ " " ~ {'minutes': 'минут', 'hours': 'часов', 'days': 'дней', 'weeks': 'недель', 'months': 'месяцев'}[freq.split()[1]] %}
                                    <option value="{{ freq }}" {% if frequency_filter == freq %}selected{% endif %}>{{ freq_display }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-4">
                            <label for="search" class="form-label fw-bold">Поиск по описанию</label>
                            <div class="input-group">
                                <input type="text" name="search" id="search" class="form-control" placeholder="Поиск по описанию" value="{{ search_query }}">
                                <button type="submit" class="btn btn-primary"><i class="fas fa-filter"></i> Применить</button>
                                <a href="{{ url_for('tasks.index') }}" class="btn btn-secondary"><i class="fas fa-times"></i> Сбросить</a>
                            </div>
                        </div>
                    </div>
                </form>

                <!-- Таблица задач -->
                <table class="table table-hover">
                    <thead>
                        <tr>
                            <th>№</th>
                            <th>Исполнитель</th>
                            <th>Описание</th>
                            <th>Состояние</th>
                            <th>Дедлайн</th>
                            <th>Частота</th>
                            <th>Действия</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for task in tasks %}
                        <tr>
                            <td>{{ task[0].task_id }}</td>
                            <td>
                                {% if task[0].role_id == 'all' %}
                                    Все сотрудники
                                {% else %}
                                    {% for role in roles %}
                                        {% if role.role_id == task[0].role_id %}
                                            {% if role.role_group and not role.role_subgroup %}
                                                Все {{ role.role_group_name }}
                                            {% else %}
                                                {{ role.role_full_name }}
                                            {% endif %}
                                        {% endif %}
                                    {% endfor %}
                                {% endif %}
                            </td>
                            <td title="{{ task[0].description }}">{{ task[0].description|truncate(50) }}</td>
                            <td class="{% if task[0].status == 'completed' %}bg-success{% elif task[0].status == 'accepted' %}bg-warning{% elif task[0].status == 'overdue' %}bg-danger{% endif %}">
                                {% if task[1] %}
                                    см. статистика
                                {% else %}
                                    {{ task[0].status }}
                                {% endif %}
                            </td>
                            <td>{{ task[0].due_at.strftime('%H:%M %d.%m.%Y') if task[0].due_at else '-' }}</td>
                            <td>{{ task[0].repeat_interval|default('-') }}</td>
                            <td>
                                {% if task[0].role_id == 'all' or (task[0].role_id in groups) %}
                                    <button class="btn btn-sm btn-info" data-bs-toggle="modal" data-bs-target="#statsModal{{ task[0].task_id }}"><i class="fas fa-chart-bar"></i></button>
                                {% endif %}
                                <button class="btn btn-sm btn-warning" data-bs-toggle="modal" data-bs-target="#editTaskModal{{ task[0].task_id }}"><i class="fas fa-pencil-alt"></i></button>
                                <form action="{{ url_for('tasks.delete', task_id=task[0].task_id) }}" method="post" style="display:inline;">
                                    <button type="submit" class="btn btn-sm btn-danger" onclick="return confirm('Вы уверены?')"><i class="fas fa-trash"></i></button>
                                </form>
                                <button class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#notifyModal{{ task[0].task_id }}"><i class="fas fa-bell"></i></button>
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>

                <!-- Пагинация -->
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <select id="per_page" data-base-url="{{ url_for('tasks.index', status=status_filter, deadline=deadline_filter, executor=executor_filter, frequency=frequency_filter, search=search_query) }}" class="form-select d-inline-block w-auto">
                            <option value="10" {% if per_page == 10 %}selected{% endif %}>10</option>
                            <option value="25" {% if per_page == 25 %}selected{% endif %}>25</option>
                            <option value="50" {% if per_page == 50 %}selected{% endif %}>50</option>
                            <option value="100" {% if per_page == 100 %}selected{% endif %}>100</option>
                        </select>
                        строк на странице
                    </div>
                    <nav>
                        <ul class="pagination">
                            <li class="page-item {% if page == 1 %}disabled{% endif %}">
                                <a class="page-link" href="{{ url_for('tasks.index', page=page-1, per_page=per_page, status=status_filter, deadline=deadline_filter, executor=executor_filter, frequency=frequency_filter, search=search_query) }}">Предыдущая</a>
                            </li>
                            <li class="page-item">
                                <span class="page-link">Страница {{ page }} из {{ total_pages }}</span>
                            </li>
                            <li class="page-item {% if page == total_pages %}disabled{% endif %}">
                                <a class="page-link" href="{{ url_for('tasks.index', page=page+1, per_page=per_page, status=status_filter, deadline=deadline_filter, executor=executor_filter, frequency=frequency_filter, search=search_query) }}">Следующая</a>
                            </li>
                            <li class="page-item">
                                <input type="number" id="page_input" min="1" max="{{ total_pages }}" class="form-control d-inline-block w-auto" style="width: 70px;" placeholder="{{ page }}">
                                <button class="btn btn-primary btn-sm" onclick="goToPage()">Перейти</button>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>
            <div class="card-footer">
                <a href="{{ url_for('dashboard.index') }}" class="btn btn-secondary">Вернуться на главную</a>
            </div>
        </div>
    </div>

    <!-- Модальное окно добавления задачи -->
    <div class="modal fade" id="addTaskModal" tabindex="-1" aria-labelledby="addTaskModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addTaskModalLabel">Добавить задачу</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form method="post" action="{{ url_for('tasks.add') }}">
                        <div class="mb-3">
                            <label for="executor_group" class="form-label">Исполнитель</label>
                            <select name="executor" id="executor_group" class="form-select" onchange="loadSubgroups(this)">
                                <option value="all">Все сотрудники</option>
                                {% for group in groups %}
                                    <option value="{{ group }}">Все {{ group }}</option>
                                {% endfor %}
                                {% for role in roles %}
                                    {% if role.role_subgroup %}
                                        <option value="{{ role.role_id }}">{{ role.role_full_name }}</option>
                                    {% endif %}
                                {% endfor %}
                            </select>
                        </div>
                        <div class="mb-3" id="subgroup-container" style="display: none;">
                            <label for="subgroup" class="form-label">Подгруппа</label>
                            <select name="subgroup" id="subgroup" class="form-select"></select>
                        </div>
                        <div class="mb-3">
                            <label for="description" class="form-label">Описание</label>
                            <textarea name="description" id="description" class="form-control" required></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="due_at" class="form-label">Дедлайн</label>
                            <input type="datetime-local" name="due_at" id="due_at" class="form-control">
                            <div class="mt-2">
                                <button type="button" class="btn btn-sm btn-outline-primary" onclick="setToday()">Сегодня</button>
                                <button type="button" class="btn btn-sm btn-outline-primary" onclick="setTomorrow()">Завтра</button>
                                <button type="button" class="btn btn-sm btn-outline-primary" onclick="setWeek()">Через неделю</button>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="repeat_interval" class="form-label">Повторение</label>
                            <select name="repeat_interval" id="repeat_interval" class="form-select" onchange="toggleCustomRepeat(this)">
                                <option value="">Нет</option>
                                <option value="daily">Ежедневно</option>
                                <option value="weekly">Еженедельно</option>
                                <option value="custom_minutes">Каждые n минут</option>
                                <option value="custom_hours">Каждые n часов</option>
                                <option value="custom_days">Каждые n дней</option>
                                <option value="custom_weeks">Каждые n недель</option>
                                <option value="custom_months">Каждые n месяцев</option>
                            </select>
                            <div id="custom_repeat_container" style="display: none;" class="mt-2">
                                <input type="number" name="custom_repeat_value" class="form-control" placeholder="Введите количество" min="1">
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="form-check">
                                <input type="checkbox" class="form-check-input" id="notification_enabled" name="notification_enabled" onchange="toggleNotificationBlock(this)">
                                <label class="form-check-label" for="notification_enabled">Настроить уведомления</label>
                            </div>
                            <div id="notification_settings" style="display: none;" class="mt-2">
                                <select name="notification_type" class="form-select">
                                    <option value="now">Отправить сейчас</option>
                                    <option value="later">Настроить позже</option>
                                </select>
                                <div id="custom-notification-options" style="display: none;" class="mt-2">
                                    <select name="custom_notification_type" class="form-select" onchange="toggleCustomNotification(this)">
                                        <option value="single">Однократное</option>
                                        <option value="repeated">Повторяющееся</option>
                                    </select>
                                    <div id="single_notification" class="mt-2" style="display: none;">
                                        <input type="datetime-local" name="single_time" class="form-control mb-2">
                                        <input type="number" name="single_offset" class="form-control mb-2" placeholder="За сколько (в минутах)">
                                    </div>
                                    <div id="repeated_notification" class="mt-2" style="display: none;">
                                        <select name="repeat_frequency" class="form-select mb-2">
                                            <option value="custom_minutes">Каждые n минут</option>
                                            <option value="custom_hours">Каждые n часов</option>
                                            <option value="custom_days">Каждые n дней</option>
                                            <option value="custom_weeks">Каждые n недель</option>
                                            <option value="custom_months">Каждые n месяцев</option>
                                        </select>
                                        <input type="number" name="repeat_frequency_value" class="form-control mb-2" placeholder="Количество">
                                        <input type="datetime-local" name="repeat_start" class="form-control mb-2">
                                        <input type="datetime-local" name="repeat_end" class="form-control mb-2">
                                        <div class="form-check">
                                            <input type="checkbox" class="form-check-input" id="fixed_times_add" name="fixed_times" onchange="toggleFixedTimes(this, 'add')">
                                            <label class="form-check-label" for="fixed_times_add">Фиксированное время</label>
                                        </div>
                                        <div id="fixed_times_container_add" style="display: none;">
                                            <input type="time" name="fixed_time_1" class="form-control mb-2">
                                            <button type="button" class="btn btn-sm btn-primary" onclick="addFixedTime('add')">+</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary mt-2">Добавить</button>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальные окна для редактирования, статистики и уведомлений -->
    {% for task in tasks %}
        <!-- Редактирование -->
        <div class="modal fade" id="editTaskModal{{ task[0].task_id }}" tabindex="-1" aria-labelledby="editTaskModalLabel{{ task[0].task_id }}" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="editTaskModalLabel{{ task[0].task_id }}">Редактировать задачу №{{ task[0].task_id }}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form method="post" action="{{ url_for('tasks.update_status', task_id=task[0].task_id) }}">
                            <div class="mb-3">
                                <label for="executor_group_{{ task[0].task_id }}" class="form-label">Исполнитель</label>
                                <select name="executor" id="executor_group_{{ task[0].task_id }}" class="form-select" onchange="loadSubgroups(this)">
                                    <option value="all" {% if task[0].role_id == 'all' %}selected{% endif %}>Все сотрудники</option>
                                    {% for group in groups %}
                                        <option value="{{ group }}" {% if task[0].role_id == group %}selected{% endif %}>Все {{ group }}</option>
                                    {% endfor %}
                                    {% for role in roles %}
                                        {% if role.role_subgroup %}
                                            <option value="{{ role.role_id }}" {% if task[0].role_id == role.role_id %}selected{% endif %}>{{ role.role_full_name }}</option>
                                        {% endif %}
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="mb-3" id="subgroup-container-{{ task[0].task_id }}" style="display: none;">
                                <label for="subgroup_{{ task[0].task_id }}" class="form-label">Подгруппа</label>
                                <select name="subgroup" id="subgroup_{{ task[0].task_id }}" class="form-select"></select>
                            </div>
                            <div class="mb-3">
                                <label for="description_{{ task[0].task_id }}" class="form-label">Описание</label>
                                <textarea name="description" id="description_{{ task[0].task_id }}" class="form-control" required>{{ task[0].description }}</textarea>
                            </div>
                            <div class="mb-3">
                                <label for="due_at_{{ task[0].task_id }}" class="form-label">Дедлайн</label>
                                <input type="datetime-local" name="due_at" id="due_at_{{ task[0].task_id }}" class="form-control" value="{{ task[0].due_at.strftime('%Y-%m-%dT%H:%M') if task[0].due_at else '' }}">
                                <div class="mt-2">
                                    <button type="button" class="btn btn-sm btn-outline-primary" onclick="setToday()">Сегодня</button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" onclick="setTomorrow()">Завтра</button>
                                    <button type="button" class="btn btn-sm btn-outline-primary" onclick="setWeek()">Через неделю</button>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label for="repeat_interval_{{ task[0].task_id }}" class="form-label">Повторение</label>
                                <select name="repeat_interval" id="repeat_interval_{{ task[0].task_id }}" class="form-select" onchange="toggleCustomRepeat(this)">
                                    <option value="" {% if not task[0].repeat_interval %}selected{% endif %}>Нет</option>
                                    <option value="daily" {% if task[0].repeat_interval == 'daily' %}selected{% endif %}>Ежедневно</option>
                                    <option value="weekly" {% if task[0].repeat_interval == 'weekly' %}selected{% endif %}>Еженедельно</option>
                                    <option value="custom_minutes" {% if task[0].repeat_interval and 'minutes' in task[0].repeat_interval %}selected{% endif %}>Каждые n минут</option>
                                    <option value="custom_hours" {% if task[0].repeat_interval and 'hours' in task[0].repeat_interval %}selected{% endif %}>Каждые n часов</option>
                                    <option value="custom_days" {% if task[0].repeat_interval and 'days' in task[0].repeat_interval %}selected{% endif %}>Каждые n дней</option>
                                    <option value="custom_weeks" {% if task[0].repeat_interval and 'weeks' in task[0].repeat_interval %}selected{% endif %}>Каждые n недель</option>
                                    <option value="custom_months" {% if task[0].repeat_interval and 'months' in task[0].repeat_interval %}selected{% endif %}>Каждые n месяцев</option>
                                </select>
                                <div id="custom_repeat_container_{{ task[0].task_id }}" style="display: {{ 'block' if task[0].repeat_interval and task[0].repeat_interval.split()|length >= 2 and task[0].repeat_interval.split()[1] in ['minutes', 'hours', 'days', 'weeks', 'months'] else 'none' }};" class="mt-2">
                                    <input type="number" name="custom_repeat_value" class="form-control" placeholder="Введите количество" min="1" value="{{ task[0].repeat_interval.split()[0] if task[0].repeat_interval and task[0].repeat_interval.split()|length >= 2 and task[0].repeat_interval.split()[1] in ['minutes', 'hours', 'days', 'weeks', 'months'] else '' }}">
                                </div>
                            </div>
                            </div>
                            <div class="mb-3">
                                <label for="status_{{ task[0].task_id }}" class="form-label">Состояние</label>
                                <select name="status" id="status_{{ task[0].task_id }}" class="form-select">
                                    <option value="sent" {% if task[0].status == 'sent' %}selected{% endif %}>Отправлено</option>
                                    <option value="accepted" {% if task[0].status == 'accepted' %}selected{% endif %}>Принято</option>
                                    <option value="completed" {% if task[0].status == 'completed' %}selected{% endif %}>Выполнено</option>
                                </select>
                            </div>
                            <button type="submit" class="btn btn-primary">Сохранить</button>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Статистика -->
        <div class="modal fade" id="statsModal{{ task[0].task_id }}" tabindex="-1" aria-labelledby="statsModalLabel{{ task[0].task_id }}" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="statsModalLabel{{ task[0].task_id }}">Статистика задачи №{{ task[0].task_id }}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Динамическая загрузка через stats -->
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Уведомления -->
        <div class="modal fade" id="notifyModal{{ task[0].task_id }}" tabindex="-1" aria-labelledby="notifyModalLabel{{ task[0].task_id }}" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="notifyModalLabel{{ task[0].task_id }}">Настройка уведомлений для задачи №{{ task[0].task_id }}</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Тип</th>
                                    <th>Время отправки</th>
                                    <th>Статус</th>
                                    <th>Действия</th>
                                </tr>
                            </thead>
                            <tbody id="notifications-table-{{ task[0].task_id }}"></tbody>
                        </table>
                        <form id="add-notification-form-{{ task[0].task_id }}">
                            <div class="mb-3">
                                <label for="notification_type_{{ task[0].task_id }}" class="form-label">Тип уведомления</label>
                                <select name="notification_type" id="notification_type_{{ task[0].task_id }}" class="form-select" onchange="toggleNotificationOptions(this, '{{ task[0].task_id }}')">
                                    <option value="reminder">Напоминание</option>
                                    <option value="deadline">Дедлайн</option>
                                    <option value="overdue">Просрочка</option>
                                    <option value="repeated">Повторяющееся</option>
                                </select>
                            </div>
                            <div id="reminder-options-{{ task[0].task_id }}" class="mb-3" style="display: block;">
                                <input type="datetime-local" name="reminder_time" class="form-control mb-2">
                                <input type="number" name="reminder_offset" class="form-control mb-2" placeholder="За сколько до дедлайна">
                                <select name="reminder_unit" class="form-select">
                                    <option value="minutes">Минуты</option>
                                    <option value="hours">Часы</option>
                                    <option value="days">Дни</option>
                                    <option value="weeks">Недели</option>
                                    <option value="months">Месяцы</option>
                                </select>
                            </div>
                            <div id="deadline-options-{{ task[0].task_id }}" class="mb-3" style="display: none;">
                                <p>Фиксировано на момент дедлайна</p>
                            </div>
                            <div id="overdue-options-{{ task[0].task_id }}" class="mb-3" style="display: none;">
                                <input type="number" name="overdue_value" class="form-control mb-2" placeholder="Значение">
                                <select name="overdue_unit" class="form-select">
                                    <option value="minutes">Минуты</option>
                                    <option value="hours">Часы</option>
                                    <option value="days">Дни</option>
                                    <option value="weeks">Недели</option>
                                    <option value="months">Месяцы</option>
                                </select>
                            </div>
                            <div id="repeated-options-{{ task[0].task_id }}" class="mb-3" style="display: none;">
                                <input type="number" name="repeat_frequency_value" class="form-control mb-2" placeholder="Количество">
                                <select name="repeat_frequency_unit" class="form-select mb-2">
                                    <option value="minutes">Минуты</option>
                                    <option value="hours">Часы</option>
                                    <option value="days">Дни</option>
                                    <option value="weeks">Недели</option>
                                    <option value="months">Месяцы</option>
                                </select>
                                <input type="number" name="repeat_start_value" class="form-control mb-2" placeholder="Начать за (значение)">
                                <select name="repeat_start_unit" class="form-select mb-2">
                                    <option value="minutes">Минуты</option>
                                    <option value="hours">Часы</option>
                                    <option value="days">Дни</option>
                                    <option value="weeks">Недели</option>
                                    <option value="months">Месяцы</option>
                                </select>
                                <select name="repeat_end" class="form-select mb-2" onchange="toggleRepeatEndOptions(this, '{{ task[0].task_id }}')">
                                    <option value="deadline">В момент дедлайна</option>
                                    <option value="after">После дедлайна</option>
                                </select>
                                <input type="number" name="repeat_end_value" class="form-control mb-2" placeholder="Значение" style="display: none;">
                                <select name="repeat_end_unit" class="form-select mb-2" style="display: none;">
                                    <option value="minutes">Минуты</option>
                                    <option value="hours">Часы</option>
                                    <option value="days">Дни</option>
                                    <option value="weeks">Недели</option>
                                    <option value="months">Месяцы</option>
                                </select>
                                <div class="form-check">
                                    <input type="checkbox" class="form-check-input" id="fixed_times_{{ task[0].task_id }}" name="fixed_times" onchange="toggleFixedTimes(this, '{{ task[0].task_id }}')">
                                    <label class="form-check-label" for="fixed_times_{{ task[0].task_id }}">Фиксированное время</label>
                                </div>
                                <div id="fixed_times_container_{{ task[0].task_id }}" style="display: none;">
                                    <input type="time" name="fixed_time_1" class="form-control mb-2">
                                    <button type="button" class="btn btn-sm btn-primary" onclick="addFixedTime('{{ task[0].task_id }}')">+</button>
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary mt-2">Добавить</button>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    </div>
                </div>
            </div>
        </div>
    {% endfor %}

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/tasks.js') }}"></script>
</body>
</html>

==================================================
Файл: templates\tasks_stats.html
==================================================

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Статистика задачи №{{ task.task_id }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body class="bg-light">
    <div class="container mt-4">
        <div class="card shadow-sm">
            <div class="card-header">
                <h5 class="card-title mb-0">Статистика задачи №{{ task.task_id }}</h5>
            </div>
            <div class="card-body">
                <p><strong>Повторение:</strong> {{ task.repeat_interval or 'Нет' }}</p>
                <p><strong>Исполнитель:</strong>
                    {% if task.role_id == 'all' %}
                        Все сотрудники
                    {% else %}
                        {% for role in roles %}
                            {% if role.role_id == task.role_id %}
                                {% if role.role_group and not role.role_subgroup %}
                                    Все {{ role.role_group_name }}
                                {% else %}
                                    {{ role.role_full_name }}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                </p>
                <h6>Выполнение пользователями:</h6>
                {% if completions %}
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Описание</th>
                                <th>Дедлайн</th>
                                <th>Роль</th>
                                <th>Пользователь</th>
                                <th>Статус</th>
                                <th>Время выполнения</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for completion in completions %}
                                <tr>
                                    <td>{{ task.description }}</td>
                                    <td>{{ task.due_at.strftime('%H:%M %d.%m.%Y') if task.due_at else '-' }}</td>
                                    <td>{{ completion.role_full_name }}</td>
                                    <td>{{ completion.user_name or completion.user_id }}</td>
                                    <td class="{% if completion.status == 'completed' %}bg-success{% elif completion.status == 'accepted' %}bg-warning{% elif completion.status == 'sent' %}bg-light{% endif %}">
                                        {{ completion.status }}
                                    </td>
                                    <td>{{ completion.completed_at.strftime('%H:%M %d.%m.%Y') if completion.completed_at else '-' }}</td>
                                </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                {% else %}
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Описание</th>
                                <th>Дедлайн</th>
                                <th>Роль</th>
                                <th>Пользователь</th>
                                <th>Статус</th>
                                <th>Время выполнения</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>{{ task.description }}</td>
                                <td>{{ task.due_at.strftime('%H:%M %d.%m.%Y') if task.due_at else '-' }}</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="text-muted">Нет данных о выполнении.</p>
                {% endif %}
            </div>
            <div class="card-footer">
                <a href="{{ url_for('tasks.index') }}" class="btn btn-secondary">Закрыть</a>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

==================================================
Файл: utils\database.py
==================================================

#utils/database.py:
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy import MetaData, Table, Column, String, Integer, Text, DateTime, ForeignKey
from config import settings
from datetime import datetime, timedelta
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = settings.DATABASE_URL
engine = create_async_engine(DATABASE_URL, echo=False)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

metadata = MetaData()

# Таблица ролей
roles_table = Table(
    "roles",
    metadata,
    Column("role_id", String, primary_key=True),
    Column("role_group", String, nullable=True),
    Column("role_group_name", String, nullable=True),
    Column("role_subgroup", String, nullable=True),
    Column("role_full_name", String, nullable=False),
    Column("rolepass", String, nullable=False),
)

# Таблица пользователей ролей
role_users_table = Table(
    "role_users",
    metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("role_id", String, nullable=False),
    Column("user_id", String, nullable=False),
    Column("user_name", String, nullable=True),
)

# Таблица задач
tasks_table = Table(
    "tasks",
    metadata,
    Column("task_id", Integer, primary_key=True, autoincrement=True),
    Column("role_id", String, nullable=False),
    Column("description", String, nullable=False),
    Column("status", String, nullable=False),
    Column("created_at", DateTime, nullable=False),
    Column("due_at", DateTime, nullable=True),
    Column("repeat_interval", String, nullable=True),
    Column("notified", Integer, default=0),
)

# Таблица кнопок для динамического меню
buttons_table = Table(
    "buttons",
    metadata,
    Column("data", String, primary_key=True),
    Column("command", Integer, nullable=False),
    Column("parentdataorcommand", String, nullable=False),
    Column("name", String, nullable=False),
    Column("type", String, nullable=False),
    Column("text", Text, nullable=True),
    Column("submdata1", String, nullable=True),
    Column("submdata2", String, nullable=True),
    Column("submdata3", String, nullable=True),
    Column("submdata4", String, nullable=True),
    Column("submdata5", String, nullable=True),
    Column("submdata6", String, nullable=True),
    Column("submdata7", String, nullable=True),
    Column("submdata8", String, nullable=True),
    Column("submdata9", String, nullable=True),
    Column("submdata10", String, nullable=True),
    Column("submdata11", String, nullable=True),
    Column("submdata12", String, nullable=True),
    Column("submdata13", String, nullable=True),
    Column("submdata14", String, nullable=True),
    Column("submdata15", String, nullable=True),
)

# Таблица завершённых задач
task_completions_table = Table(
    "task_completions",
    metadata,
    Column("task_id", Integer, ForeignKey("tasks.task_id"), primary_key=True),
    Column("user_id", String, ForeignKey("role_users.user_id"), primary_key=True),
    Column("status", String, nullable=False, default="accepted"),
    Column("completed_at", DateTime, nullable=True),
)

# Таблица уведомлений
task_notifications_table = Table(
    "task_notifications",
    metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("task_id", Integer, ForeignKey("tasks.task_id"), nullable=False),
    Column("type", String, nullable=False),
    Column("scheduled_time", DateTime, nullable=True),
    Column("repeat_interval", String, nullable=True),
    Column("start_offset_value", Integer, nullable=True),
    Column("start_offset_unit", String, nullable=True),
    Column("end_offset_value", Integer, nullable=True),
    Column("end_offset_unit", String, nullable=True),
    Column("fixed_times", String, nullable=True),
    Column("status", String, nullable=False, default="scheduled"),
)

# Инициализация базы данных
async def init_db():
    logger.info("Инициализация базы данных...")
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)

        # Проверка существующих данных
        roles_exist = (await conn.execute(roles_table.select().limit(1))).fetchone() is not None
        tasks_exist = (await conn.execute(tasks_table.select().limit(1))).fetchone() is not None
        buttons_exist = (await conn.execute(buttons_table.select().limit(1))).fetchone() is not None
        completions_exist = (await conn.execute(task_completions_table.select().limit(1))).fetchone() is not None
        notifications_exist = (await conn.execute(task_notifications_table.select().limit(1))).fetchone() is not None

        if not roles_exist:
            logger.info("Добавление тестовых ролей...")
            await conn.execute(
                roles_table.insert(),
                [
                    {"role_id": "r1", "role_group": "voz", "role_group_name": "Вожатый", "role_subgroup": "1", "role_full_name": "Вожатый 1-го отряда", "rolepass": "pass_voz_1"},
                    {"role_id": "r2", "role_group": "voz", "role_group_name": "Вожатый", "role_subgroup": "2", "role_full_name": "Вожатый 2-го отряда", "rolepass": "pass_voz_2"},
                    {"role_id": "r14", "role_group": None, "role_group_name": "Диджей", "role_subgroup": None, "role_full_name": "Диджей", "rolepass": "dj2025"},
                ]
            )
            await conn.execute(
                role_users_table.insert(),
                [
                    {"role_id": "r1", "user_id": "5760551190", "user_name": "Иван Иванов"},
                    {"role_id": "r2", "user_id": "1234567890", "user_name": "Пётр Петров"},
                    {"role_id": "r14", "user_id": "9876543210", "user_name": "Анна Сидорова"},
                ]
            )

        if not tasks_exist:
            logger.info("Добавление тестовых задач...")
            await conn.execute(
                tasks_table.insert(),
                [
                    {"role_id": "voz", "description": "Провести собрание вожатых", "status": "accepted", "created_at": datetime.now(), "due_at": datetime.now() + timedelta(days=1), "repeat_interval": None, "notified": 0},
                    {"role_id": "r14", "description": "Подготовить плейлист", "status": "sent", "created_at": datetime.now(), "due_at": datetime.now() + timedelta(hours=5), "repeat_interval": None, "notified": 0},
                ]
            )

        if not buttons_exist:
            logger.info("Добавление тестовых кнопок...")
            await conn.execute(
                buttons_table.insert(),
                [
                    {
                        "data": "voz",
                        "command": 0,
                        "parentdataorcommand": "start",
                        "name": "Главное меню вожатых",
                        "type": "menu",
                        "text": "Меню для вожатых",
                        "submdata1": "voz_info",
                        "submdata2": "voz_link",
                        "submdata3": None,
                        "submdata4": None,
                        "submdata5": None,
                        "submdata6": None,
                        "submdata7": None,
                        "submdata8": None,
                        "submdata9": None,
                        "submdata10": None,
                        "submdata11": None,
                        "submdata12": None,
                        "submdata13": None,
                        "submdata14": None,
                        "submdata15": None,
                    },
                    {
                        "data": "voz_info",
                        "command": 0,
                        "parentdataorcommand": "voz",
                        "name": "Информация",
                        "type": "text",
                        "text": "Вы - вожатый! Ваша задача - вдохновлять детей.",
                        "submdata1": None,
                        "submdata2": None,
                        "submdata3": None,
                        "submdata4": None,
                        "submdata5": None,
                        "submdata6": None,
                        "submdata7": None,
                        "submdata8": None,
                        "submdata9": None,
                        "submdata10": None,
                        "submdata11": None,
                        "submdata12": None,
                        "submdata13": None,
                        "submdata14": None,
                        "submdata15": None,
                    },
                    {
                        "data": "voz_link",
                        "command": 0,
                        "parentdataorcommand": "voz",
                        "name": "Полезная ссылка",
                        "type": "url",
                        "text": "https://example.com",
                        "submdata1": None,
                        "submdata2": None,
                        "submdata3": None,
                        "submdata4": None,
                        "submdata5": None,
                        "submdata6": None,
                        "submdata7": None,
                        "submdata8": None,
                        "submdata9": None,
                        "submdata10": None,
                        "submdata11": None,
                        "submdata12": None,
                        "submdata13": None,
                        "submdata14": None,
                        "submdata15": None,
                    },
                ]
            )

        if not completions_exist:
            logger.info("Добавление тестовых данных в task_completions...")
            await conn.execute(
                task_completions_table.insert(),
                [
                    {"task_id": 1, "user_id": "5760551190", "status": "completed", "completed_at": datetime.now()},
                    {"task_id": 1, "user_id": "1234567890", "status": "accepted", "completed_at": None},
                ]
            )

        if not notifications_exist:
            logger.info("Добавление тестовых уведомлений...")
            await conn.execute(
                task_notifications_table.insert(),
                [
                    {"task_id": 1, "type": "deadline", "scheduled_time": datetime.now() + timedelta(days=1), "repeat_interval": None, "start_offset": None, "end_offset": None, "fixed_times": None, "status": "scheduled"},
                ]
            )

        await conn.commit()
    logger.info("База данных инициализирована.")

# Функции для работы с базой данных
async def get_role_by_password(password: str):
    async with async_session() as session:
        result = await session.execute(roles_table.select().where(roles_table.c.rolepass == password))
        return result.fetchone()

async def get_role_by_id(role_id: str):
    async with async_session() as session:
        result = await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))
        return result.fetchone()

async def get_roles():
    async with async_session() as session:
        result = await session.execute(roles_table.select())
        return result.fetchall()

async def bind_user_to_role(user_id: str, role_id: str, user_name: str = None):
    async with async_session() as session:
        await session.execute(
            role_users_table.insert().values(user_id=user_id, role_id=role_id, user_name=user_name)
        )
        await session.commit()

async def get_user_role(user_id: str):
    async with async_session() as session:
        result = await session.execute(role_users_table.select().where(role_users_table.c.user_id == user_id))
        return result.fetchone()

async def unbind_user_from_role(user_id: str):
    async with async_session() as session:
        await session.execute(role_users_table.delete().where(role_users_table.c.user_id == user_id))
        await session.commit()

async def get_tasks(role_id: str = None, role_group: str = None, all_tasks: bool = False):
    async with async_session() as session:
        if all_tasks:
            result = await session.execute(tasks_table.select().where(tasks_table.c.role_id == "all"))
            return result.fetchall()
        elif role_group:
            result = await session.execute(tasks_table.select().where(tasks_table.c.role_id == role_group))
            return result.fetchall()
        elif role_id:
            result = await session.execute(tasks_table.select().where(tasks_table.c.role_id == role_id))
            return result.fetchall()
        return []

async def update_task_status(task_id: int, new_status: str):
    async with async_session() as session:
        await session.execute(
            tasks_table.update().where(tasks_table.c.task_id == task_id).values(status=new_status)
        )
        await session.commit()

async def get_button_by_data(data: str):
    async with async_session() as session:
        result = await session.execute(buttons_table.select().where(buttons_table.c.data == data))
        return result.fetchone()

async def get_users_by_role_id(role_id: str):
    async with async_session() as session:
        result = await session.execute(role_users_table.select().where(role_users_table.c.role_id == role_id))
        return result.fetchall()

async def add_task_completion(task_id: int, user_id: str, status: str = "accepted", completed_at=None):
    async with async_session() as session:
        result = await session.execute(
            task_completions_table.select()
            .where(task_completions_table.c.task_id == task_id)
            .where(task_completions_table.c.user_id == user_id)
        )
        existing_record = result.fetchone()

        if existing_record:
            await session.execute(
                task_completions_table.update()
                .where(task_completions_table.c.task_id == task_id)
                .where(task_completions_table.c.user_id == user_id)
                .values(status=status, completed_at=completed_at)
            )
        else:
            await session.execute(
                task_completions_table.insert().values(
                    task_id=task_id,
                    user_id=user_id,
                    status=status,
                    completed_at=completed_at
                )
            )
        await session.commit()

async def get_task_completions(task_id: int):
    async with async_session() as session:
        result = await session.execute(
            task_completions_table.select()
            .join(role_users_table, task_completions_table.c.user_id == role_users_table.c.user_id)
            .join(roles_table, role_users_table.c.role_id == roles_table.c.role_id)
            .where(task_completions_table.c.task_id == task_id)
        )
        return result.fetchall()

async def add_task(role_id: str, description: str, status: str, due_at: DateTime = None, repeat_interval: str = None):
    async with async_session() as session:
        result = await session.execute(
            tasks_table.insert().values(
                role_id=role_id,
                description=description,
                status=status,
                created_at=datetime.now(),
                due_at=due_at,
                repeat_interval=repeat_interval,
                notified=0
            )
        )
        await session.commit()
        return result.inserted_primary_key[0]

async def add_notification(task_id: int, type: str, scheduled_time: DateTime = None, repeat_interval: str = None,
                          start_offset_value: int = None, start_offset_unit: str = None,
                          end_offset_value: int = None, end_offset_unit: str = None, fixed_times: str = None):
    async with async_session() as session:
        await session.execute(
            task_notifications_table.insert().values(
                task_id=task_id,
                type=type,
                scheduled_time=scheduled_time,
                repeat_interval=repeat_interval,
                start_offset_value=start_offset_value,
                start_offset_unit=start_offset_unit,
                end_offset_value=end_offset_value,
                end_offset_unit=end_offset_unit,
                fixed_times=fixed_times,
                status="scheduled"
            )
        )
        await session.commit()

async def get_notifications(task_id: int):
    async with async_session() as session:
        result = await session.execute(
            task_notifications_table.select().where(task_notifications_table.c.task_id == task_id)
        )
        return result.fetchall()

if __name__ == "__main__":
    import asyncio
    asyncio.run(init_db())

==================================================
Файл: utils\export_excel.py
==================================================

# utils/export_excel.py
from io import BytesIO
import pandas as pd
from utils.database import buttons_table, async_session
from sqlalchemy.future import select

from io import BytesIO
import pandas as pd
from utils.database import buttons_table, async_session
from sqlalchemy.future import select

async def export_buttons_to_excel():
    """
    Экспортирует все данные из таблицы buttons_table в файл Excel.
    Возвращает BytesIO объект с файлом.
    """
    async with async_session() as session:
        query = select(buttons_table)
        result = await session.execute(query)
        buttons = result.fetchall()

    if not buttons:
        return None

    data = []
    for button in buttons:
        row = {
            "Data": button.data,
            "Command": "Команда" if button.command == 1 else "Кнопка",
            "Parent/Command": button.parentdataorcommand,
            "Name": button.name,
            "Type": button.type,
            "Text": button.text or "Отсутствует"
        }
        for i in range(1, 16):
            submdata = getattr(button, f"submdata{i}", None)
            row[f"Submenu {i}"] = submdata if submdata else ""
        data.append(row)

    df = pd.DataFrame(data)
    output = BytesIO()
    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
        df.to_excel(writer, sheet_name="Buttons", index=False)
        worksheet = writer.sheets["Buttons"]
        for i, col in enumerate(df.columns):
            max_len = max(df[col].astype(str).map(len).max(), len(col)) + 2
            worksheet.set_column(i, i, min(max_len, 50))

    output.seek(0)
    return output

==================================================
Файл: utils\notifications.py
==================================================

# utils/notifications.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.date import DateTrigger
from datetime import datetime
from utils.database import get_tasks, get_users_by_role_id, get_notifications, add_notification, async_session, task_notifications_table, role_users_table
from aiogram import Bot
import logging
import asyncio

logger = logging.getLogger(__name__)

class NotificationService:
    def __init__(self, bot: Bot):
        self.bot = bot
        self.scheduler = AsyncIOScheduler()
        self.scheduler.configure({'event_loop': asyncio.get_event_loop()})  # Привязываем к текущему циклу событий
        logger.info(f"Scheduler initialized: {self.scheduler}")
        self.running = False

    def start(self):
        """Запуск планировщика уведомлений"""
        logger.info(f"Before start, scheduler: {self.scheduler}")
        if not self.running:
            self.scheduler.start()  # Убираем await, так как это синхронный метод
            self.running = True
            logger.info("Планировщик уведомлений запущен")
            asyncio.create_task(self.schedule_existing_tasks())  # Запускаем асинхронно

    async def shutdown(self):
        """Остановка планировщика"""
        if self.running:
            self.scheduler.shutdown()
            self.running = False
            logger.info("Планировщик уведомлений остановлен")
        
    async def schedule_existing_tasks(self):
        """Планирование уведомлений для существующих задач"""
        tasks = await get_tasks()
        logger.info(f"Загружено {len(tasks)} задач для планирования")
        for task in tasks:
            await self.process_task(task)

    async def process_task(self, task):
        """Обработка задачи и планирование уведомлений"""
        logger.info(f"Обрабатывается задача {task.task_id}: notified={task.notified}, due_at={task.due_at}")
        if task.notified == 0 and task.due_at:
            await self.schedule_task_notification(task.task_id, task.due_at, task.description, task.role_id)

    async def schedule_task_notification(self, task_id: int, due_at: datetime, description: str, role_id: str, notification_id=None):
        logger.info(f"Планирование задачи {task_id}: due_at={due_at}, repeat_interval=None")
        
        # Получаем всех пользователей в зависимости от role_id
        if role_id == "all":
            async with async_session() as session:
                result = await session.execute(role_users_table.select())
                users = result.fetchall()
        else:
            users = await get_users_by_role_id(role_id)
        
        if not users:
            logger.warning(f"Для роли {role_id} нет пользователей для уведомления")
            return

        async def send_notification():
            message = f"Напоминание: задача #{task_id}\nОписание: {description}\nДедлайн: {due_at.strftime('%H:%M %d.%m.%Y')}"
            for user in users:
                try:
                    await self.bot.send_message(user.user_id, message)
                    logger.info(f"Уведомление отправлено пользователю {user.user_id}")
                except Exception as e:
                    logger.error(f"Ошибка отправки уведомления пользователю {user.user_id}: {e}")
            
            # Обновляем статус уведомления
            async with async_session() as session:
                await session.execute(
                    task_notifications_table.update()
                    .where(task_notifications_table.c.task_id == task_id)
                    .where(task_notifications_table.c.id == notification_id)
                    .values(status='sent')
                )
                await session.commit()
            logger.info(f"Уведомление для задачи {task_id} отправлено")

        job_id = f"task_{task_id}_notification_{notification_id or 'deadline'}"
        self.scheduler.add_job(
            send_notification,
            trigger=DateTrigger(run_date=due_at),
            id=job_id,
            replace_existing=True
        )
        logger.info(f"Запланировано уведомление для {task_id} на {due_at} с ID {job_id}")

    async def add_notification(self, task_id: int, notification_type: str, scheduled_time: datetime = None):
        await add_notification(task_id, notification_type, scheduled_time)
        tasks = await get_tasks(role_id=None)
        task = next((t for t in tasks if t.task_id == task_id), None)
        if task:
            notifications = await get_notifications(task_id)
            latest_notification = notifications[-1] if notifications else None
            await self.schedule_task_notification(task.task_id, scheduled_time or task.due_at, task.description, task.role_id, latest_notification.id if latest_notification else None)

    # ... (остальной код) ...

def init_notifications(bot: Bot):
    """Инициализация сервиса уведомлений"""
    return NotificationService(bot)

==================================================
Файл: web\buttons.py
==================================================



==================================================
Файл: web\dashboard.py
==================================================

# web/dashboard.py
from quart import Blueprint, render_template
from quart_auth import login_required

dashboard_bp = Blueprint('dashboard', __name__)

@dashboard_bp.route('/')
@login_required
async def index():
    return await render_template('dashboard.html')

==================================================
Файл: web\roles.py
==================================================

# web/roles.py
from quart import Blueprint, render_template, request, redirect, url_for, flash, jsonify
from quart_auth import login_required
from utils.database import async_session, roles_table, role_users_table, get_roles, get_users_by_role_id
from sqlalchemy.sql import select, update, delete
import random
import string
import logging
from web import bot_instance  # Для отправки сообщений через Telegram

logger = logging.getLogger(__name__)

roles_bp = Blueprint('roles', __name__)

@roles_bp.route('/', methods=['GET'])
@login_required
async def index():
    args = request.args
    page = int(args.get('page', 1))
    per_page = int(args.get('per_page', 25))
    group_filter = args.get('group', 'all')
    search_query = args.get('search', '')
    only_with_users = args.get('only_with_users') == 'on'

    async with async_session() as session:
        roles_query = select(roles_table)
        if group_filter != 'all':
            roles_query = roles_query.where(roles_table.c.role_group == group_filter)
        if search_query:
            roles_query = roles_query.where(roles_table.c.role_full_name.ilike(f"%{search_query}%"))
        if only_with_users:
            roles_query = roles_query.join(role_users_table, roles_table.c.role_id == role_users_table.c.role_id, isouter=False)

        roles_result = await session.execute(roles_query)
        all_roles = roles_result.fetchall()
        total = len(all_roles)
        offset = (page - 1) * per_page
        roles_query = roles_query.offset(offset).limit(per_page)
        roles_result = await session.execute(roles_query)
        roles = roles_result.fetchall()

        groups = sorted(set(role.role_group for role in all_roles if role.role_group))
        users_by_role = {role.role_id: await get_users_by_role_id(role.role_id) for role in roles}

    total_pages = (total + per_page - 1) // per_page

    return await render_template(
        'roles.html',
        roles=roles,
        users_by_role=users_by_role,
        groups=groups,
        page=page,
        per_page=per_page,
        total_pages=total_pages,
        group_filter=group_filter,
        search_query=search_query,
        only_with_users=only_with_users
    )

@roles_bp.route('/add', methods=['POST'])
@login_required
async def add_role():
    form = await request.form
    role_id = form.get('role_id')
    role_full_name = form.get('role_full_name')
    role_group = form.get('role_group') or None
    role_subgroup = form.get('role_subgroup') or None
    rolepass = form.get('rolepass') or ''.join(random.choices(string.ascii_lowercase + string.digits, k=7))

    if not role_id or not role_full_name or not all(c in (string.ascii_letters + string.digits) for c in role_id):
        await flash("Некорректный ID роли или полное название", "danger")
        return redirect(url_for('roles.index'))

    async with async_session() as session:
        existing_role = await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))
        if existing_role.fetchone():
            await flash("Роль с таким ID уже существует", "danger")
            return redirect(url_for('roles.index'))

        await session.execute(
            roles_table.insert().values(
                role_id=role_id,
                role_full_name=role_full_name,
                role_group=role_group,
                role_subgroup=role_subgroup,
                rolepass=rolepass
            )
        )
        await session.commit()

    await flash("Роль успешно добавлена", "success")
    return redirect(url_for('roles.index'))

@roles_bp.route('/update', methods=['POST'])
@login_required
async def update_role():
    data = await request.get_json()
    role_id = data.get('role_id')
    updates = {k: v for k, v in data.items() if k != 'role_id' and v is not None}

    if not role_id or not updates:
        return jsonify({'success': False, 'error': 'Нет данных для обновления'})

    async with async_session() as session:
        await session.execute(
            roles_table.update()
            .where(roles_table.c.role_id == role_id)
            .values(**updates)
        )
        await session.commit()

    return jsonify({'success': True})



@roles_bp.route('/delete/<role_id>', methods=['POST'])
@login_required
async def delete_role(role_id):
    async with async_session() as session:
        await session.execute(role_users_table.delete().where(role_users_table.c.role_id == role_id))
        await session.execute(roles_table.delete().where(roles_table.c.role_id == role_id))
        await session.commit()
    await flash("Роль удалена", "success")
    return redirect(url_for('roles.index'))

@roles_bp.route('/add_user', methods=['POST'])
@login_required
async def add_user():
    data = await request.get_json()
    role_id = data.get('role_id')
    user_id = data.get('user_id')
    user_name = data.get('user_name') or None

    if not role_id or not user_id or not user_id.isdigit():
        return jsonify({'success': False, 'error': 'Некорректный Telegram ID'})

    async with async_session() as session:
        role = (await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))).fetchone()
        if not role:
            return jsonify({'success': False, 'error': 'Роль не найдена'})

        existing_user = (await session.execute(
            role_users_table.select()
            .where(role_users_table.c.role_id == role_id)
            .where(role_users_table.c.user_id == user_id)
        )).fetchone()
        if existing_user:
            return jsonify({'success': False, 'error': 'Пользователь уже привязан'})

        await session.execute(
            role_users_table.insert().values(role_id=role_id, user_id=user_id, user_name=user_name)
        )
        await session.commit()

        if bot_instance:
            try:
                await bot_instance.send_message(
                    user_id,
                    f"Вы привязаны к роли '{role.role_full_name}'. Пароль: {role.rolepass}\n"
                    f"Для входа в бот используйте команду /start и введите этот пароль."
                )
                logger.info(f"Сообщение отправлено пользователю {user_id}")
            except Exception as e:
                logger.error(f"Ошибка отправки сообщения пользователю {user_id}: {e}")
                return jsonify({'success': True, 'warning': 'Пользователь добавлен, но сообщение не отправлено'})

    return jsonify({'success': True})

@roles_bp.route('/delete_user', methods=['POST'])
@login_required
async def delete_user():
    data = await request.get_json()
    role_id = data.get('role_id')
    user_id = data.get('user_id')

    async with async_session() as session:
        await session.execute(
            role_users_table.delete()
            .where(role_users_table.c.role_id == role_id)
            .where(role_users_table.c.user_id == user_id)
        )
        await session.commit()

    return jsonify({'success': True})

@roles_bp.route('/regenerate_password/<role_id>', methods=['POST'])
@login_required
async def regenerate_password(role_id):
    new_password = ''.join(random.choices(string.ascii_lowercase + string.digits, k=7))
    async with async_session() as session:
        # Получаем текущих пользователей роли
        users = await get_users_by_role_id(role_id)
        role = (await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))).fetchone()

        # Удаляем привязанных пользователей
        await session.execute(role_users_table.delete().where(role_users_table.c.role_id == role_id))
        # Обновляем пароль
        await session.execute(
            roles_table.update()
            .where(roles_table.c.role_id == role_id)
            .values(rolepass=new_password)
        )
        await session.commit()

        # Уведомляем пользователей о сбросе
        if bot_instance and users:
            for user in users:
                try:
                    await bot_instance.send_message(
                        user.user_id,
                        f"Пароль для роли '{role.role_full_name}' был обновлён. Новый пароль: {new_password}\n"
                        f"Все пользователи отвязаны. Для повторной привязки обратитесь к администратору."
                    )
                    logger.info(f"Сообщение отправлено пользователю {user.user_id}")
                except Exception as e:
                    logger.error(f"Ошибка отправки сообщения пользователю {user.user_id}: {e}")

    await flash("Пароль обновлён, пользователи отвязаны и уведомлены", "success")
    return redirect(url_for('roles.index'))

@roles_bp.route('/send_password/<role_id>', methods=['POST'])
@login_required
async def send_password(role_id):
    async with async_session() as session:
        role = (await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))).fetchone()
        users = await get_users_by_role_id(role_id)

    if not role or not users or not bot_instance:
        await flash("Ошибка: роль не найдена, нет пользователей или бот не инициализирован", "danger")
        return redirect(url_for('roles.index'))

    for user in users:
        try:
            await bot_instance.send_message(user.user_id, f"Пароль для роли '{role.role_full_name}': {role.rolepass}")
            logger.info(f"Пароль отправлен пользователю {user.user_id}")
        except Exception as e:
            logger.error(f"Ошибка отправки пароля пользователю {user.user_id}: {e}")

    await flash("Пароль отправлен всем пользователям роли", "success")
    return redirect(url_for('roles.index'))

@roles_bp.route('/add_from_table', methods=['POST'])
@login_required
async def add_from_table():
    data = await request.get_json()
    role_id = data.get('role_id')
    role_full_name = data.get('role_full_name')
    role_group = data.get('role_group') or None
    role_subgroup = data.get('role_subgroup') or None
    rolepass = data.get('rolepass') or ''.join(random.choices(string.ascii_lowercase + string.digits, k=7))

    if not role_id or not role_full_name or not all(c in (string.ascii_letters + string.digits) for c in role_id):
        return jsonify({'success': False, 'error': 'Некорректный ID роли или полное название'})

    async with async_session() as session:
        existing_role = await session.execute(roles_table.select().where(roles_table.c.role_id == role_id))
        if existing_role.fetchone():
            return jsonify({'success': False, 'error': 'Роль с таким ID уже существует'})

        await session.execute(
            roles_table.insert().values(
                role_id=role_id,
                role_full_name=role_full_name,
                role_group=role_group,
                role_subgroup=role_subgroup,
                rolepass=rolepass
            )
        )
        await session.commit()

    return jsonify({'success': True})

==================================================
Файл: web\tasks.py
==================================================

from quart import Blueprint, render_template, request, redirect, url_for, flash, jsonify
from quart_auth import login_required
from utils.database import get_roles, add_task, update_task_status, async_session, tasks_table, task_completions_table, roles_table, role_users_table, add_notification, get_task_completions, task_notifications_table
from sqlalchemy.sql import select
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

tasks_bp = Blueprint('tasks', __name__)

from web import notification_service

@tasks_bp.route('/', methods=['GET'])
@login_required
async def index():
    args = request.args
    page = int(args.get('page', 1))
    per_page = int(args.get('per_page', 25))
    status_filter = args.get('status', 'all')
    deadline_filter = args.get('deadline', 'all')
    executor_filter = args.get('executor', 'all')
    frequency_filter = args.get('frequency', 'all')
    search_query = args.get('search', '')

    async with async_session() as session:
        roles = await get_roles()
        groups = sorted(set(role.role_group for role in roles if role.role_group))

        query = select(tasks_table)
        if status_filter != 'all':
            query = query.where(tasks_table.c.status == status_filter)
        now = datetime.now()
        if deadline_filter == 'overdue':
            query = query.where(tasks_table.c.due_at < now)
        elif deadline_filter == 'today':
            query = query.where(tasks_table.c.due_at >= now).where(tasks_table.c.due_at < now + timedelta(days=1))
        elif deadline_filter == 'future':
            query = query.where(tasks_table.c.due_at >= now + timedelta(days=1))
        if executor_filter != 'all':
            query = query.where(tasks_table.c.role_id == executor_filter)
        if frequency_filter != 'all':
            query = query.where(tasks_table.c.repeat_interval == frequency_filter)
        if status_filter == 'overdue':
            query = query.where(tasks_table.c.due_at < now).where(tasks_table.c.status != 'completed')
        if search_query:
            query = query.where(tasks_table.c.description.ilike(f"%{search_query}%"))

        total_tasks = (await session.execute(query)).fetchall()
        total = len(total_tasks)
        offset = (page - 1) * per_page
        query = query.offset(offset).limit(per_page)
        tasks_result = await session.execute(query)
        tasks = tasks_result.fetchall()

        # Обновление статуса просроченных задач
        for task in tasks:
            if task.due_at and task.due_at < now and task.status != 'completed':
                await session.execute(
                    tasks_table.update()
                    .where(tasks_table.c.task_id == task.task_id)
                    .values(status='overdue')
                )
        await session.commit()
        tasks_result = await session.execute(query)  # Повторный запрос после обновления
        tasks = tasks_result.fetchall()

        # Проверка на отсутствующие роли и добавление флага is_group_task
        role_ids = {role.role_id for role in roles}
        tasks_with_flags = []
        for task in tasks:
            if task.role_id in role_ids or task.role_id == 'all':
                # Проверяем, является ли задача групповой
                is_group_task = (task.role_id == 'all' or 
                                 (task.role_id in groups and 
                                  not any(role.role_id == task.role_id and role.role_subgroup for role in roles)))
                tasks_with_flags.append((task, is_group_task))
        
        frequency_result = await session.execute(select(tasks_table.c.repeat_interval).distinct())
        frequencies = [row[0] for row in frequency_result if row[0]]

    total_pages = (total + per_page - 1) // per_page

    return await render_template(
        'tasks.html',
        tasks=tasks_with_flags,  # Передаем список кортежей (task, is_group_task)
        roles=roles,
        groups=groups,
        page=page,
        per_page=per_page,
        total_pages=total_pages,
        total=total,
        status_filter=status_filter,
        deadline_filter=deadline_filter,
        executor_filter=executor_filter,
        frequency_filter=frequency_filter,
        search_query=search_query,
        frequencies=frequencies
    )

@tasks_bp.route('/add', methods=['POST'])
@login_required
async def add():
    form = await request.form
    role_id = form.get('executor')
    subgroup = form.get('subgroup')
    description = form.get('description')
    due_at_str = form.get('due_at')
    repeat_interval = form.get('repeat_interval')
    custom_repeat_value = form.get('custom_repeat_value')
    notification_type = form.get('notification_type')
    notification_enabled = form.get('notification_enabled') == 'on'

    if not description:
        await flash("Описание задачи обязательно", "danger")
        return redirect(url_for('tasks.index'))

    if subgroup and subgroup != "all":
        role_id = subgroup

    due_at = datetime.strptime(due_at_str, '%Y-%m-%dT%H:%M') if due_at_str else None

    # Обработка пользовательского интервала повторения (добавлены недели и месяцы)
    if repeat_interval and repeat_interval.startswith("custom_"):
        if custom_repeat_value:
            unit = repeat_interval.split('_')[1]
            repeat_interval = f"{custom_repeat_value} {unit}"

    task_id = await add_task(role_id, description, "sent", due_at, repeat_interval)

    # Обработка уведомлений
    if notification_enabled:
        if notification_type == "now" and notification_service:
            await notification_service.schedule_task_notification(task_id, datetime.now(), description, role_id)
        elif notification_type == "deadline" and due_at:
            await add_notification(task_id, "deadline", scheduled_time=due_at)
        elif notification_type == "custom":
            custom_type = form.get('custom_notification_type')
            if custom_type == "single":
                single_time = form.get('single_time')
                single_offset = form.get('single_offset')
                single_unit = form.get('single_unit', 'minutes')
                scheduled_time = datetime.strptime(single_time, '%Y-%m-%dT%H:%M') if single_time else None
                if single_offset and due_at and not scheduled_time:
                    delta = {
                        'minutes': timedelta(minutes=int(single_offset)),
                        'hours': timedelta(hours=int(single_offset)),
                        'days': timedelta(days=int(single_offset)),
                        'weeks': timedelta(weeks=int(single_offset)),
                        'months': timedelta(days=int(single_offset) * 30)
                    }[single_unit]
                    scheduled_time = due_at - delta
                await add_notification(task_id, "single", scheduled_time=scheduled_time)
            elif custom_type == "repeated":
                repeat_frequency = form.get('repeat_frequency')
                repeat_value = form.get('repeat_frequency_value')
                repeat_start = form.get('repeat_start')
                repeat_end = form.get('repeat_end')
                fixed_times = [form.get(f'fixed_time_{i}') for i in range(1, 10) if form.get(f'fixed_time_{i}')]
                repeat_interval = f"{repeat_value} {repeat_frequency.split('_')[1]}" if repeat_value else None
                start_time = datetime.strptime(repeat_start, '%Y-%m-%dT%H:%M') if repeat_start else None
                end_time = datetime.strptime(repeat_end, '%Y-%m-%dT%H:%M') if repeat_end else None
                await add_notification(
                    task_id, "repeated",
                    repeat_interval=repeat_interval,
                    scheduled_time=start_time,
                    end_offset=end_time,
                    fixed_times=",".join(fixed_times) if fixed_times else None
                )

    await flash("Задача успешно добавлена!", "success")
    return redirect(url_for('tasks.index'))

@tasks_bp.route('/delete/<int:task_id>', methods=['POST'])
@login_required
async def delete(task_id):
    async with async_session() as session:
        await session.execute(tasks_table.delete().where(tasks_table.c.task_id == task_id))
        await session.commit()
    await flash("Задача удалена", "success")
    return redirect(url_for('tasks.index'))

@tasks_bp.route('/update_status/<int:task_id>', methods=['POST'])
@login_required
async def update_status(task_id):
    form = await request.form
    role_id = form.get('executor')
    subgroup = form.get('subgroup')
    description = form.get('description')
    due_at_str = form.get('due_at')
    repeat_interval = form.get('repeat_interval')
    custom_repeat_value = form.get('custom_repeat_value')
    new_status = form.get('status')

    if not description:
        await flash("Описание задачи обязательно", "danger")
        return redirect(url_for('tasks.index'))

    if subgroup and subgroup != "all":
        role_id = subgroup

    due_at = datetime.strptime(due_at_str, '%Y-%m-%dT%H:%M') if due_at_str else None

    if repeat_interval and repeat_interval.startswith("custom_"):
        if custom_repeat_value:
            unit = repeat_interval.split('_')[1]
            repeat_interval = f"{custom_repeat_value} {unit}"
        else:
            repeat_interval = None

    async with async_session() as session:
        await session.execute(
            tasks_table.update()
            .where(tasks_table.c.task_id == task_id)
            .values(
                role_id=role_id,
                description=description,
                status=new_status if new_status in ["sent", "accepted", "completed"] else "sent",
                due_at=due_at,
                repeat_interval=repeat_interval
            )
        )
        await session.commit()

    await flash(f"Задача #{task_id} успешно обновлена", "success")
    return redirect(url_for('tasks.index'))

@tasks_bp.route('/get_subgroups', methods=['GET'])
@login_required
async def get_subgroups():
    group = request.args.get('group')
    if not group or group == 'all':
        return jsonify([])
    async with async_session() as session:
        result = await session.execute(
            roles_table.select().where(roles_table.c.role_group == group).where(roles_table.c.role_subgroup.isnot(None))
        )
        subgroups = result.fetchall()
    return jsonify([{"role_id": row.role_id, "role_full_name": row.role_full_name} for row in subgroups])

@tasks_bp.route('/stats/<int:task_id>', methods=['GET'])
@login_required
async def stats(task_id):
    async with async_session() as session:
        task_result = await session.execute(tasks_table.select().where(tasks_table.c.task_id == task_id))
        task = task_result.fetchone()
        if not task:
            await flash("Задача не найдена", "danger")
            return redirect(url_for('tasks.index'))
        completions = await get_task_completions(task_id)
        roles = await get_roles()  # Добавлено для отображения ролей в статистике
        return await render_template('tasks_stats.html', task=task, completions=completions, roles=roles)

@tasks_bp.route('/get_notifications', methods=['GET'])
@login_required
async def get_notifications():
    task_id = request.args.get('task_id', type=int)
    if not task_id:
        return jsonify([])
    async with async_session() as session:
        result = await session.execute(
            task_notifications_table.select().where(task_notifications_table.c.task_id == task_id)
        )
        notifications = result.fetchall()
    return jsonify([
        {
            'id': n.id,
            'type': n.type,
            'scheduled_time': n.scheduled_time.isoformat() if n.scheduled_time else None,
            'repeat_interval': n.repeat_interval,
            'status': n.status
        } for n in notifications
    ])

@tasks_bp.route('/add_notification', methods=['POST'])
@login_required
async def add_notification_route():
    data = await request.get_json()
    task_id = data.get('task_id')
    notification_type = data.get('notification_type')

    async with async_session() as session:
        task_result = await session.execute(tasks_table.select().where(tasks_table.c.task_id == task_id))
        task = task_result.fetchone()
        if not task:
            return jsonify({'success': False, 'error': 'Задача не найдена'})

        scheduled_time = None
        repeat_interval = None
        start_offset = None
        end_offset = None
        fixed_times = None

        if notification_type == 'reminder':
            if data.get('reminder_time'):
                scheduled_time = datetime.fromisoformat(data['reminder_time'])
            elif data.get('reminder_offset'):
                offset = int(data['reminder_offset'])
                unit = data.get('reminder_unit', 'minutes')
                delta = {
                    'minutes': timedelta(minutes=offset),
                    'hours': timedelta(hours=offset),
                    'days': timedelta(days=offset),
                    'weeks': timedelta(weeks=offset),
                    'months': timedelta(days=offset * 30)
                }[unit]
                scheduled_time = task.due_at - delta
        elif notification_type == 'deadline':
            scheduled_time = task.due_at
        elif notification_type == 'overdue':
            value = int(data.get('overdue_value', 0))
            unit = data.get('overdue_unit', 'hours')
            delta = {
                'minutes': timedelta(minutes=value),
                'hours': timedelta(hours=value),
                'days': timedelta(days=value),
                'weeks': timedelta(weeks=value),
                'months': timedelta(days=value * 30)
            }[unit]
            scheduled_time = task.due_at + delta
        elif notification_type == 'repeated':
            freq_value = int(data.get('repeat_frequency_value', 0))
            freq_unit = data.get('repeat_frequency_unit')
            repeat_interval = f"{freq_value} {freq_unit}"
            start_value = int(data.get('repeat_start_value', 0))
            start_unit = data.get('repeat_start_unit')
            start_delta = {
                'minutes': timedelta(minutes=start_value),
                'hours': timedelta(hours=start_value),
                'days': timedelta(days=start_value),
                'weeks': timedelta(weeks=start_value),
                'months': timedelta(days=start_value * 30)
            }[start_unit]
            scheduled_time = task.due_at - start_delta
            end_value = None
            end_unit = None
            if data.get('repeat_end') == 'after':
                end_value = int(data.get('repeat_end_value', 0))
                end_unit = data.get('repeat_end_unit')
                end_delta = {
                    'minutes': timedelta(minutes=end_value),
                    'hours': timedelta(hours=end_value),
                    'days': timedelta(days=end_value),
                    'weeks': timedelta(weeks=end_value),
                    'months': timedelta(days=end_value * 30)
                }[end_unit]
            fixed_times = ','.join(data.get('fixed_times', [])) if data.get('fixed_times') else None

            await add_notification(task_id, notification_type, scheduled_time, repeat_interval,
                                start_offset_value=start_value, start_offset_unit=start_unit,
                                end_offset_value=end_value, end_offset_unit=end_unit, fixed_times=fixed_times)
    return jsonify({'success': True})

@tasks_bp.route('/cancel_notification', methods=['POST'])
@login_required
async def cancel_notification():
    data = await request.get_json()
    task_id = data.get('task_id')
    notification_id = data.get('notification_id')

    async with async_session() as session:
        await session.execute(
            task_notifications_table.update()
            .where(task_notifications_table.c.id == notification_id)
            .where(task_notifications_table.c.task_id == task_id)
            .values(status='cancelled')
        )
        await session.commit()

    if notification_service and hasattr(notification_service, 'scheduler'):
        try:
            notification_service.scheduler.remove_job(f"task_{task_id}_notification_{notification_id}")
        except:
            logger.warning(f"Не удалось удалить задачу уведомления task_{task_id}_notification_{notification_id}")
    
    return jsonify({'success': True})

==================================================
Файл: web\__init__.py
==================================================

#web/__init__.py
from quart import Quart, render_template, request, redirect, url_for, session, flash
from quart_auth import QuartAuth, AuthUser, login_required, login_user, logout_user
from config import settings
from utils.database import async_session, engine as async_engine
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Создание приложения Quart
app = Quart(__name__, template_folder="../templates")
app.config['SECRET_KEY'] = 'your-secret-key-here'  # Замените на безопасный ключ в продакшене
auth = QuartAuth(app)

# Переменные для интеграции с ботом и уведомлениями
notification_service = None
bot_instance = None

def set_notification_service(service):
    """Функция для передачи сервиса уведомлений из main.py"""
    global notification_service
    notification_service = service

def set_bot(bot):
    """Функция для передачи экземпляра бота из main.py"""
    global bot_instance
    bot_instance = bot

# Главный маршрут (перенаправляет на авторизацию или dashboard)
@app.route('/')
async def index():
    return redirect(url_for('dashboard.index'))  # @login_required сам проверит авторизацию

# Маршрут для страницы входа
@app.route('/login', methods=['GET', 'POST'])
async def login():
    if request.method == 'POST':
        form = await request.form
        login = form.get('login')
        password = form.get('password')

        if login == settings.DIRECTOR_LOGIN and password == settings.DIRECTOR_PASSWORD:
            user = AuthUser("director")
            login_user(user)
            logger.info(f"Успешная авторизация для пользователя {login}")
            return redirect(url_for('dashboard.index'))
        else:
            await flash("Неверный логин или пароль", "danger")
            logger.warning(f"Неудачная попытка входа: логин={login}")
    
    return await render_template('login.html')

# Маршрут для выхода
@app.route('/logout')
@login_required
async def logout():
    logout_user()
    logger.info("Пользователь вышел из системы")
    return redirect(url_for('login'))

# Регистрация blueprints
from .dashboard import dashboard_bp
from .tasks import tasks_bp
from .roles import roles_bp
app.register_blueprint(dashboard_bp, url_prefix='/dashboard')
app.register_blueprint(tasks_bp, url_prefix='/tasks')
app.register_blueprint(roles_bp, url_prefix='/roles')

# Заглушки для будущих модулей (раскомментировать при реализации)
# from .dynmenu import dynmenu_bp
# from .messages import messages_bp
# app.register_blueprint(dynmenu_bp, url_prefix='/dynmenu')
# app.register_blueprint(messages_bp, url_prefix='/messages')

# Закрытие соединения с базой данных
@app.after_request
async def close_db(response):
    await async_engine.dispose()
    return response

if __name__ == "__main__":
    app.run(host='localhost', port=5000, debug=True)

